(globalThis.webpackChunk_croquet_microverse=globalThis.webpackChunk_croquet_microverse||[]).push([[578],{3578:()=>{{const t=new THREE.OrthographicCamera(-1,1,1,-1,0,1),r=new THREE.BufferGeometry;r.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),r.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2)),THREE.FullScreenQuad=class FullScreenQuad{constructor(e){this._mesh=new THREE.Mesh(r,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,t)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}},THREE.Pass=class Pass{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}}THREE.CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`};{const s=new THREE.Matrix4;THREE.CSMFrustum=class CSMFrustum{constructor(e){e=e||{},this.vertices={near:[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3],far:[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3]},void 0!==e.projectionMatrix&&this.setFromProjectionMatrix(e.projectionMatrix,e.maxFar||1e4)}setFromProjectionMatrix(e,r){const a=0===e.elements[11];return s.copy(e).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach(function(e){e.applyMatrix4(s)}),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach(function(e){e.applyMatrix4(s);var t=Math.abs(e.z);a?e.z*=Math.min(r/t,1):e.multiplyScalar(Math.min(r/t,1))}),this.vertices}split(r,e){for(;r.length>e.length;)e.push(new CSMFrustum);e.length=r.length;for(let t=0;t<r.length;t++){const a=e[t];if(0===t)for(let e=0;e<4;e++)a.vertices.near[e].copy(this.vertices.near[e]);else for(let e=0;e<4;e++)a.vertices.near[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],r[t-1]);if(t===r.length-1)for(let e=0;e<4;e++)a.vertices.far[e].copy(this.vertices.far[e]);else for(let e=0;e<4;e++)a.vertices.far[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],r[t])}}toSpace(t,r){for(let e=0;e<4;e++)r.vertices.near[e].copy(this.vertices.near[e]).applyMatrix4(t),r.vertices.far[e].copy(this.vertices.far[e]).applyMatrix4(t)}}}var e;e={lights_fragment_begin:`
GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

		// NOTE: Depth gets larger away from the camera.
		// cascade.x is closer, cascade.y is further
		cascade = CSM_cascades[ i ];
		cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
		closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
		margin = 0.25 * pow( closestEdge, 2.0 );
		csmx = cascade.x - margin / 2.0;
		csmy = cascade.y + margin / 2.0;
		if( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

			float dist = min( linearDepth - csmx, csmy - linearDepth );
			float ratio = clamp( dist / margin, 0.0, 1.0 );
			if( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {

				vec3 prevColor = directLight.color;
				directionalLightShadow = directionalLightShadows[ i ];
				directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

				bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
				directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

			}

			ReflectedLight prevLight = reflectedLight;
			RE_Direct( directLight, geometry, material, reflectedLight );

			bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
			float blendRatio = shouldBlend ? ratio : 1.0;

			reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
			reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
			reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
			reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

		}

	}
	#pragma unroll_loop_end
	#else

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

		directionalLightShadow = directionalLightShadows[ i ];
		if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

		#endif

		if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,lights_pars_begin:`
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[CSM_CASCADES];
uniform float cameraNear;
uniform float shadowFar;
#endif
	`+THREE.ShaderChunk.lights_pars_begin},THREE.CSMShader=e;{const O=/^[og]\s*(.+)?/,k=/^mtllib /,B=/^usemtl /,V=/^usemap /,n=new THREE.Vector3,i=new THREE.Vector3,o=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Vector3,G=new THREE.Color;function ParserState(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const r=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){var r=this._finalize(!1),e=(r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1),{index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&0<t.length?t[t.length-1]:"",smooth:(void 0!==r?r:this).smooth,groupStart:void 0!==r?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}});return this.materials.push(e),e},currentMaterial:function(){if(0<this.materials.length)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&1<this.materials.length)for(let e=this.materials.length-1;0<=e;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},r&&r.name&&"function"==typeof r.clone){const a=r.clone(0);a.inherited=!0,this.object.materials.push(a)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){e=parseInt(e,10);return 3*(0<=e?e-1:e+t/3)},parseNormalIndex:function(e,t){e=parseInt(e,10);return 3*(0<=e?e-1:e+t/3)},parseUVIndex:function(e,t){e=parseInt(e,10);return 2*(0<=e?e-1:e+t/2)},addVertex:function(e,t,r){var a=this.vertices;const s=this.object.geometry.vertices;s.push(a[e+0],a[e+1],a[e+2]),s.push(a[t+0],a[t+1],a[t+2]),s.push(a[r+0],a[r+1],a[r+2])},addVertexPoint:function(e){var t=this.vertices;const r=this.object.geometry.vertices;r.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){var t=this.vertices;const r=this.object.geometry.vertices;r.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,r){var a=this.normals;const s=this.object.geometry.normals;s.push(a[e+0],a[e+1],a[e+2]),s.push(a[t+0],a[t+1],a[t+2]),s.push(a[r+0],a[r+1],a[r+2])},addFaceNormal:function(e,t,r){var a=this.vertices;const s=this.object.geometry.normals;n.fromArray(a,e),i.fromArray(a,t),o.fromArray(a,r),c.subVectors(o,i),l.subVectors(n,i),c.cross(l),c.normalize(),s.push(c.x,c.y,c.z),s.push(c.x,c.y,c.z),s.push(c.x,c.y,c.z)},addColor:function(e,t,r){var a=this.colors;const s=this.object.geometry.colors;void 0!==a[e]&&s.push(a[e+0],a[e+1],a[e+2]),void 0!==a[t]&&s.push(a[t+0],a[t+1],a[t+2]),void 0!==a[r]&&s.push(a[r+0],a[r+1],a[r+2])},addUV:function(e,t,r){var a=this.uvs;const s=this.object.geometry.uvs;s.push(a[e+0],a[e+1]),s.push(a[t+0],a[t+1]),s.push(a[r+0],a[r+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){var t=this.uvs;const r=this.object.geometry.uvs;r.push(t[e+0],t[e+1])},addFace:function(e,t,r,a,s,n,i,o,l){var c=this.vertices.length;let u=this.parseVertexIndex(e,c),d=this.parseVertexIndex(t,c),h=this.parseVertexIndex(r,c);this.addVertex(u,d,h),this.addColor(u,d,h),void 0!==i&&""!==i?(e=this.normals.length,u=this.parseNormalIndex(i,e),d=this.parseNormalIndex(o,e),h=this.parseNormalIndex(l,e),this.addNormal(u,d,h)):this.addFaceNormal(u,d,h),void 0!==a&&""!==a?(t=this.uvs.length,u=this.parseUVIndex(a,t),d=this.parseUVIndex(s,t),h=this.parseUVIndex(n,t),this.addUV(u,d,h),this.object.geometry.hasUVIndices=!0):this.addDefaultUV()},addPointGeometry:function(r){this.object.geometry.type="Points";var a=this.vertices.length;for(let e=0,t=r.length;e<t;e++){var s=this.parseVertexIndex(r[e],a);this.addVertexPoint(s),this.addColor(s)}},addLineGeometry:function(r,a){this.object.geometry.type="Line";var s=this.vertices.length,n=this.uvs.length;for(let e=0,t=r.length;e<t;e++)this.addVertexLine(this.parseVertexIndex(r[e],s));for(let e=0,t=a.length;e<t;e++)this.addUVLine(this.parseUVIndex(a[e],n))}};return e.startObject("",!1),e}class OBJLoader extends THREE.Loader{constructor(e){super(e),this.materials=null}load(t,r,e,a){const s=this,n=new THREE.FileLoader(this.manager);n.setPath(this.path),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(t,function(e){try{r(s.parse(e))}catch(e){a?a(e):console.error(e),s.manager.itemError(t)}},e,a)}setMaterials(e){return this.materials=e,this}parse(e){const a=new ParserState;var r=(e=-1!==(e=-1!==e.indexOf("\r\n")?e.replace(/\r\n/g,"\n"):e).indexOf("\\\n")?e.replace(/\\\n/g,""):e).split("\n");let s="",n;let i=[];var o,U="function"==typeof"".trimLeft;for(let e=0,t=r.length;e<t;e++)if(s=r[e],0!==(s=U?s.trimLeft():s.trim()).length&&"#"!==(n=s.charAt(0)))if("v"===n){var l=s.split(/\s+/);switch(l[0]){case"v":a.vertices.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3])),7<=l.length?(G.setRGB(parseFloat(l[4]),parseFloat(l[5]),parseFloat(l[6])).convertSRGBToLinear(),a.colors.push(G.r,G.g,G.b)):a.colors.push(void 0,void 0,void 0);break;case"vn":a.normals.push(parseFloat(l[1]),parseFloat(l[2]),parseFloat(l[3]));break;case"vt":a.uvs.push(parseFloat(l[1]),parseFloat(l[2]))}}else if("f"===n){const S=s.slice(1).trim();var c,u=S.split(/\s+/);const M=[];for(let e=0,t=u.length;e<t;e++){const A=u[e];0<A.length&&(c=A.split("/"),M.push(c))}var d=M[0];for(let e=1,t=M.length-1;e<t;e++){var h=M[e],p=M[e+1];a.addFace(d[0],h[0],p[0],d[1],h[1],p[1],d[2],h[2],p[2])}}else if("l"===n){const L=s.substring(1).trim().split(" ");let r=[];const H=[];if(-1===s.indexOf("/"))r=L;else for(let e=0,t=L.length;e<t;e++){var f=L[e].split("/");""!==f[0]&&r.push(f[0]),""!==f[1]&&H.push(f[1])}a.addLineGeometry(r,H)}else if("p"===n){const N=s.slice(1).trim();var m=N.split(" ");a.addPointGeometry(m)}else if(null!==(i=O.exec(s))){m=(" "+i[0].slice(1).trim()).slice(1);a.startObject(m)}else if(B.test(s))a.object.startMaterial(s.substring(7).trim(),a.materialLibraries);else if(k.test(s))a.materialLibraries.push(s.substring(7).trim());else if(V.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===n){1<(i=s.split(" ")).length?(o=i[1].trim().toLowerCase(),a.object.smooth="0"!==o&&"off"!==o):a.object.smooth=!0;const I=a.object.currentMaterial();I&&(I.smooth=a.object.smooth)}else"\0"!==s&&console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"');a.finalize();const g=new THREE.Group;if(g.materialLibraries=[].concat(a.materialLibraries),!0==!(1===a.objects.length&&0===a.objects[0].geometry.vertices.length))for(let e=0,t=a.objects.length;e<t;e++){var E=a.objects[e],v=E.geometry,T=E.materials,y="Line"===v.type,R="Points"===v.type;let r=!1;if(0!==v.vertices.length){const F=new THREE.BufferGeometry,C=(F.setAttribute("position",new THREE.Float32BufferAttribute(v.vertices,3)),0<v.normals.length&&F.setAttribute("normal",new THREE.Float32BufferAttribute(v.normals,3)),0<v.colors.length&&(r=!0,F.setAttribute("color",new THREE.Float32BufferAttribute(v.colors,3))),!0===v.hasUVIndices&&F.setAttribute("uv",new THREE.Float32BufferAttribute(v.uvs,2)),[]);for(let t=0,e=T.length;t<e;t++){var x=T[t],w=x.name+"_"+x.smooth+"_"+r;let e=a.materials[w];if(null!==this.materials)if(e=this.materials.create(x.name),!y||!e||e instanceof THREE.LineBasicMaterial){if(R&&e&&!(e instanceof THREE.PointsMaterial)){const _=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(_,e),_.color.copy(e.color),_.map=e.map,e=_}}else{const P=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(P,e),P.color.copy(e.color),e=P}void 0===e&&((e=y?new THREE.LineBasicMaterial:R?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial).name=x.name,e.flatShading=!x.smooth,e.vertexColors=r,a.materials[w]=e),C.push(e)}let e;if(1<C.length){for(let e=0,t=T.length;e<t;e++){var b=T[e];F.addGroup(b.groupStart,b.groupCount,e)}e=new(y?THREE.LineSegments:R?THREE.Points:THREE.Mesh)(F,C)}else e=new(y?THREE.LineSegments:R?THREE.Points:THREE.Mesh)(F,C[0]);e.name=E.name,g.add(e)}}else if(0<a.vertices.length){const t=new THREE.PointsMaterial({size:1,sizeAttenuation:!1}),D=new THREE.BufferGeometry;D.setAttribute("position",new THREE.Float32BufferAttribute(a.vertices,3)),0<a.colors.length&&void 0!==a.colors[0]&&(D.setAttribute("color",new THREE.Float32BufferAttribute(a.colors,3)),t.vertexColors=!0);e=new THREE.Points(D,t);g.add(e)}return g}}THREE.OBJLoader=OBJLoader}{class MTLLoader extends THREE.Loader{constructor(e){super(e)}load(t,r,e,a){const s=this,n=""===this.path?THREE.LoaderUtils.extractUrlBase(t):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,function(e){try{r(s.parse(e,n))}catch(e){a?a(e):console.error(e),s.manager.itemError(t)}},e,a)}setMaterialOptions(e){return this.materialOptions=e,this}parse(e,t){var a=e.split("\n");let s={};var n=/\s+/;const i={};for(let e=0;e<a.length;e++){let r=a[e];if(0!==(r=r.trim()).length&&"#"!==r.charAt(0)){var o=r.indexOf(" ");let e=0<=o?r.substring(0,o):r,t=(e=e.toLowerCase(),0<=o?r.substring(o+1):"");t=t.trim(),"newmtl"===e?(s={name:t},i[t]=s):"ka"===e||"kd"===e||"ks"===e||"ke"===e?(o=t.split(n,3),s[e]=[parseFloat(o[0]),parseFloat(o[1]),parseFloat(o[2])]):s[e]=t}}const r=new MaterialCreator(this.resourcePath||t,this.materialOptions);return r.setCrossOrigin(this.crossOrigin),r.setManager(this.manager),r.setMaterials(i),r}}class MaterialCreator{constructor(e="",t={}){this.baseUrl=e,this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=void 0!==this.options.side?this.options.side:THREE.FrontSide,this.wrap=void 0!==this.options.wrap?this.options.wrap:THREE.RepeatWrapping}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const t={};for(const s in e){var r=e[s];const n={};t[s]=n;for(const i in r){let e=!0,t=r[i];var a=i.toLowerCase();switch(a){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(t=[t[0]/255,t[1]/255,t[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===t[0]&&0===t[1]&&0===t[2]&&(e=!1)}e&&(n[a]=t)}}return t}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray}create(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const a=this;var t=this.materialsInfo[e];const s={name:e,side:this.side};function setMapForType(e,t){if(!s[e]){t=a.getTextureParams(t,s);const r=a.loadTexture(function resolveURL(e,t){return"string"!=typeof t||""===t?"":/^https?:\/\//i.test(t)?t:e+t}(a.baseUrl,t.url));r.repeat.copy(t.scale),r.offset.copy(t.offset),r.wrapS=a.wrap,r.wrapT=a.wrap,"map"!==e&&"emissiveMap"!==e||(r.encoding=THREE.sRGBEncoding),s[e]=r}}for(const n in t){var r=t[n];let e;if(""!==r)switch(n.toLowerCase()){case"kd":s.color=(new THREE.Color).fromArray(r).convertSRGBToLinear();break;case"ks":s.specular=(new THREE.Color).fromArray(r).convertSRGBToLinear();break;case"ke":s.emissive=(new THREE.Color).fromArray(r).convertSRGBToLinear();break;case"map_kd":setMapForType("map",r);break;case"map_ks":setMapForType("specularMap",r);break;case"map_ke":setMapForType("emissiveMap",r);break;case"norm":setMapForType("normalMap",r);break;case"map_bump":case"bump":setMapForType("bumpMap",r);break;case"map_d":setMapForType("alphaMap",r),s.transparent=!0;break;case"ns":s.shininess=parseFloat(r);break;case"d":(e=parseFloat(r))<1&&(s.opacity=e,s.transparent=!0);break;case"tr":e=parseFloat(r),0<(e=this.options&&this.options.invertTrProperty?1-e:e)&&(s.opacity=1-e,s.transparent=!0)}}return this.materials[e]=new THREE.MeshPhongMaterial(s),this.materials[e]}getTextureParams(e,t){const r={scale:new THREE.Vector2(1,1),offset:new THREE.Vector2(0,0)},a=e.split(/\s+/);let s;return 0<=(s=a.indexOf("-bm"))&&(t.bumpScale=parseFloat(a[s+1]),a.splice(s,2)),0<=(s=a.indexOf("-s"))&&(r.scale.set(parseFloat(a[s+1]),parseFloat(a[s+2])),a.splice(s,4)),0<=(s=a.indexOf("-o"))&&(r.offset.set(parseFloat(a[s+1]),parseFloat(a[s+2])),a.splice(s,4)),r.url=a.join(" ").trim(),r}loadTexture(e,t,r,a,s){const n=void 0!==this.manager?this.manager:THREE.DefaultLoadingManager;let i=n.getHandler(e);(i=null===i?new THREE.TextureLoader(n):i).setCrossOrigin&&i.setCrossOrigin(this.crossOrigin);const o=i.load(e,r,a,s);return void 0!==t&&(o.mapping=t),o}}THREE.MTLLoader=MTLLoader}!function(){class GLTFLoader extends THREE.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new GLTFMaterialsClearcoatExtension(e)}),this.register(function(e){return new GLTFTextureBasisUExtension(e)}),this.register(function(e){return new GLTFTextureWebPExtension(e)}),this.register(function(e){return new GLTFMaterialsSheenExtension(e)}),this.register(function(e){return new GLTFMaterialsTransmissionExtension(e)}),this.register(function(e){return new GLTFMaterialsVolumeExtension(e)}),this.register(function(e){return new GLTFMaterialsIorExtension(e)}),this.register(function(e){return new GLTFMaterialsSpecularExtension(e)}),this.register(function(e){return new GLTFLightsExtension(e)}),this.register(function(e){return new GLTFMeshoptCompression(e)})}load(t,r,e,a){const s=this;let n;n=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:THREE.LoaderUtils.extractUrlBase(t),this.manager.itemStart(t);function wc(e){a?a(e):console.error(e),s.manager.itemError(t),s.manager.itemEnd(t)}const i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,function(e){try{s.parse(e,n,function(e){r(e),s.manager.itemEnd(t)},wc)}catch(e){wc(e)}},e,wc)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,r,a){let s;const n={},i={};if("string"==typeof e)s=e;else if(THREE.LoaderUtils.decodeText(new Uint8Array(e,0,4))===p){try{n[h.KHR_BINARY_GLTF]=new GLTFBinaryExtension(e)}catch(e){return void(a&&a(e))}s=n[h.KHR_BINARY_GLTF].content}else s=THREE.LoaderUtils.decodeText(new Uint8Array(e));var o=JSON.parse(s);if(void 0===o.asset||o.asset.version[0]<2)a&&a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));else{const u=new GLTFParser(o,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){var l=this.pluginCallbacks[e](u);i[l.name]=l,n[l.name]=!0}if(o.extensionsUsed)for(let e=0;e<o.extensionsUsed.length;++e){var c=o.extensionsUsed[e];const d=o.extensionsRequired||[];switch(c){case h.KHR_MATERIALS_UNLIT:n[c]=new GLTFMaterialsUnlitExtension;break;case h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:n[c]=new GLTFMaterialsPbrSpecularGlossinessExtension;break;case h.KHR_DRACO_MESH_COMPRESSION:n[c]=new GLTFDracoMeshCompressionExtension(o,this.dracoLoader);break;case h.KHR_TEXTURE_TRANSFORM:n[c]=new GLTFTextureTransformExtension;break;case h.KHR_MESH_QUANTIZATION:n[c]=new GLTFMeshQuantizationExtension;break;default:0<=d.indexOf(c)&&void 0===i[c]&&console.warn('THREE.GLTFLoader: Unknown extension "'+c+'".')}}u.setExtensions(n),u.setPlugins(i),u.parse(r,a)}}parseAsync(r,a){const s=this;return new Promise(function(e,t){s.parse(r,a,e,t)})}}function GLTFRegistry(){let r={};return{get:function(e){return r[e]},add:function(e,t){r[e]=t},remove:function(e){delete r[e]},removeAll:function(){r={}}}}const h={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class GLTFLightsExtension{constructor(e){this.parser=e,this.name=h.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const r=this.parser;var a=this.parser.json.nodes||[];for(let e=0,t=a.length;e<t;e++){var s=a[e];s.extensions&&s.extensions[this.name]&&void 0!==s.extensions[this.name].light&&r._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser;var r="light:"+e;let a=t.cache.get(r);if(a)return a;var s=t.json;const n=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let i;const o=new THREE.Color(16777215);void 0!==n.color&&o.fromArray(n.color);var l=void 0!==n.range?n.range:0;switch(n.type){case"directional":(i=new THREE.DirectionalLight(o)).target.position.set(0,0,-1),i.add(i.target);break;case"point":(i=new THREE.PointLight(o)).distance=l;break;case"spot":(i=new THREE.SpotLight(o)).distance=l,n.spot=n.spot||{},n.spot.innerConeAngle=void 0!==n.spot.innerConeAngle?n.spot.innerConeAngle:0,n.spot.outerConeAngle=void 0!==n.spot.outerConeAngle?n.spot.outerConeAngle:Math.PI/4,i.angle=n.spot.outerConeAngle,i.penumbra=1-n.spot.innerConeAngle/n.spot.outerConeAngle,i.target.position.set(0,0,-1),i.add(i.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+n.type)}return i.position.set(0,0,0),i.decay=2,void 0!==n.intensity&&(i.intensity=n.intensity),i.name=t.createUniqueName(n.name||"light_"+e),a=Promise.resolve(i),t.cache.add(r,a),a}createNodeAttachment(e){const t=this,r=this.parser;e=r.json.nodes[e];const a=(e.extensions&&e.extensions[this.name]||{}).light;return void 0===a?null:this._loadLight(a).then(function(e){return r._getNodeRef(t.cache,a,e)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=h.KHR_MATERIALS_UNLIT}getMaterialType(){return THREE.MeshBasicMaterial}extendParams(e,t,r){const a=[];e.color=new THREE.Color(1,1,1),e.opacity=1;var s,t=t.pbrMetallicRoughness;return t&&(Array.isArray(t.baseColorFactor)&&(s=t.baseColorFactor,e.color.fromArray(s),e.opacity=s[3]),void 0!==t.baseColorTexture&&a.push(r.assignTexture(e,"map",t.baseColorTexture))),Promise.all(a)}}class GLTFMaterialsClearcoatExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser;e=r.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const a=[];var e=e.extensions[this.name];return void 0!==e.clearcoatFactor&&(t.clearcoat=e.clearcoatFactor),void 0!==e.clearcoatTexture&&a.push(r.assignTexture(t,"clearcoatMap",e.clearcoatTexture)),void 0!==e.clearcoatRoughnessFactor&&(t.clearcoatRoughness=e.clearcoatRoughnessFactor),void 0!==e.clearcoatRoughnessTexture&&a.push(r.assignTexture(t,"clearcoatRoughnessMap",e.clearcoatRoughnessTexture)),void 0!==e.clearcoatNormalTexture&&(a.push(r.assignTexture(t,"clearcoatNormalMap",e.clearcoatNormalTexture)),void 0!==e.clearcoatNormalTexture.scale&&(e=e.clearcoatNormalTexture.scale,t.clearcoatNormalScale=new THREE.Vector2(e,e))),Promise.all(a)}}class GLTFMaterialsSheenExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_SHEEN}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser;e=r.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const a=[];t.sheenColor=new THREE.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;e=e.extensions[this.name];return void 0!==e.sheenColorFactor&&t.sheenColor.fromArray(e.sheenColorFactor),void 0!==e.sheenRoughnessFactor&&(t.sheenRoughness=e.sheenRoughnessFactor),void 0!==e.sheenColorTexture&&a.push(r.assignTexture(t,"sheenColorMap",e.sheenColorTexture)),void 0!==e.sheenRoughnessTexture&&a.push(r.assignTexture(t,"sheenRoughnessMap",e.sheenRoughnessTexture)),Promise.all(a)}}class GLTFMaterialsTransmissionExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser;e=r.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const a=[];e=e.extensions[this.name];return void 0!==e.transmissionFactor&&(t.transmission=e.transmissionFactor),void 0!==e.transmissionTexture&&a.push(r.assignTexture(t,"transmissionMap",e.transmissionTexture)),Promise.all(a)}}class GLTFMaterialsVolumeExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_VOLUME}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser;e=r.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const a=[];e=e.extensions[this.name],t.thickness=void 0!==e.thicknessFactor?e.thicknessFactor:0,void 0!==e.thicknessTexture&&a.push(r.assignTexture(t,"thicknessMap",e.thicknessTexture)),t.attenuationDistance=e.attenuationDistance||0,e=e.attenuationColor||[1,1,1];return t.attenuationColor=new THREE.Color(e[0],e[1],e[2]),Promise.all(a)}}class GLTFMaterialsIorExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_IOR}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){e=this.parser.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();e=e.extensions[this.name];return t.ior=void 0!==e.ior?e.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(e){this.parser=e,this.name=h.KHR_MATERIALS_SPECULAR}getMaterialType(e){e=this.parser.json.materials[e];return e.extensions&&e.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const r=this.parser;e=r.json.materials[e];if(!e.extensions||!e.extensions[this.name])return Promise.resolve();const a=[];var e=e.extensions[this.name],s=(t.specularIntensity=void 0!==e.specularFactor?e.specularFactor:1,void 0!==e.specularTexture&&a.push(r.assignTexture(t,"specularIntensityMap",e.specularTexture)),e.specularColorFactor||[1,1,1]);return t.specularColor=new THREE.Color(s[0],s[1],s[2]),void 0!==e.specularColorTexture&&a.push(r.assignTexture(t,"specularColorMap",e.specularColorTexture).then(function(e){e.encoding=THREE.sRGBEncoding})),Promise.all(a)}}class GLTFTextureBasisUExtension{constructor(e){this.parser=e,this.name=h.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json;var a=r.textures[e];if(!a.extensions||!a.extensions[this.name])return null;var a=a.extensions[this.name],s=t.options.ktx2Loader;if(s)return t.loadTextureImage(e,a.source,s);if(r.extensionsRequired&&0<=r.extensionsRequired.indexOf(this.name))throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}}class GLTFTextureWebPExtension{constructor(e){this.parser=e,this.name=h.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const r=this.name,a=this.parser,s=a.json;var e=s.textures[t];if(!e.extensions||!e.extensions[r])return null;var e=e.extensions[r];const n=s.images[e.source];let i=a.textureLoader;return n.uri&&null!==(e=a.options.manager.getHandler(n.uri))&&(i=e),this.detectSupport().then(function(e){if(e)return a.loadTextureImage(t,n,i);if(s.extensionsRequired&&0<=s.extensionsRequired.indexOf(r))throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return a.loadTexture(t)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}})),this.isSupported}}class GLTFMeshoptCompression{constructor(e){this.name=h.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json;e=t.bufferViews[e];if(e.extensions&&e.extensions[this.name]){const i=e.extensions[this.name];e=this.parser.getDependency("buffer",i.buffer);const o=this.parser.options.meshoptDecoder;if(o&&o.supported)return Promise.all([e,o.ready]).then(function(e){var t=i.byteOffset||0,r=i.byteLength||0,a=i.count,s=i.byteStride,n=new ArrayBuffer(a*s),e=new Uint8Array(e[0],t,r);return o.decodeGltfBuffer(new Uint8Array(n),a,s,e,i.mode,i.filter),n});if(t.extensionsRequired&&0<=t.extensionsRequired.indexOf(this.name))throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return null}}const p="glTF",l={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(e){this.name=h.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12);if(this.header={magic:THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==p)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");var r=this.header.length-12;const a=new DataView(e,12);let s=0;for(;s<r;){var n,i=a.getUint32(s,!0),o=(s+=4,a.getUint32(s,!0));s+=4,o===l.JSON?(n=new Uint8Array(e,12+s,i),this.content=THREE.LoaderUtils.decodeText(n)):o===l.BIN&&(n=12+s,this.body=e.slice(n,n+i)),s+=i}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=h.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){var r=this.json;const a=this.dracoLoader;var s=e.extensions[this.name].bufferView,n=e.extensions[this.name].attributes;const i={},o={},l={};for(const p in n){var c=m[p]||p.toLowerCase();i[c]=n[p]}for(const f in e.attributes){var u,d,h=m[f]||f.toLowerCase();void 0!==n[f]&&(u=r.accessors[e.attributes[f]],d=T[u.componentType],l[h]=d,o[h]=!0===u.normalized)}return t.getDependency("bufferView",s).then(function(e){return new Promise(function(s){a.decodeDracoFile(e,function(e){for(const r in e.attributes){const a=e.attributes[r];var t=o[r];void 0!==t&&(a.normalized=t)}s(e)},i,l)})})}}class GLTFTextureTransformExtension{constructor(){this.name=h.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),void 0===t.offset&&void 0===t.rotation&&void 0===t.scale||(e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class GLTFMeshStandardSGMaterial extends THREE.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const r=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),a=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),s=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),n=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),i=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),o={specular:{value:(new THREE.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(e){for(const t in o)e.uniforms[t]=o[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",r).replace("#include <metalnessmap_pars_fragment>",a).replace("#include <roughnessmap_fragment>",s).replace("#include <metalnessmap_fragment>",n).replace("#include <lights_physical_fragment>",i)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(e){o.specular.value=e}},specularMap:{get:function(){return o.specularMap.value},set:function(e){(o.specularMap.value=e)?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(e){o.glossiness.value=e}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(e){(o.glossinessMap.value=e)?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class GLTFMaterialsPbrSpecularGlossinessExtension{constructor(){this.name=h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return GLTFMeshStandardSGMaterial}extendParams(e,t,r){var a,t=t.extensions[this.name];e.color=new THREE.Color(1,1,1),e.opacity=1;const s=[];return Array.isArray(t.diffuseFactor)&&(a=t.diffuseFactor,e.color.fromArray(a),e.opacity=a[3]),void 0!==t.diffuseTexture&&s.push(r.assignTexture(e,"map",t.diffuseTexture)),e.emissive=new THREE.Color(0,0,0),e.glossiness=void 0!==t.glossinessFactor?t.glossinessFactor:1,e.specular=new THREE.Color(1,1,1),Array.isArray(t.specularFactor)&&e.specular.fromArray(t.specularFactor),void 0!==t.specularGlossinessTexture&&(a=t.specularGlossinessTexture,s.push(r.assignTexture(e,"glossinessMap",a)),s.push(r.assignTexture(e,"specularMap",a))),Promise.all(s)}createMaterial(e){const t=new GLTFMeshStandardSGMaterial(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=THREE.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class GLTFMeshQuantizationExtension{constructor(){this.name=h.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends THREE.Interpolant{constructor(e,t,r,a){super(e,t,r,a)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,a=this.valueSize,s=e*a*3+a;for(let e=0;e!==a;e++)t[e]=r[s+e];return t}}GLTFCubicSplineInterpolant.prototype.beforeStart_=GLTFCubicSplineInterpolant.prototype.copySampleValue_,GLTFCubicSplineInterpolant.prototype.afterEnd_=GLTFCubicSplineInterpolant.prototype.copySampleValue_,GLTFCubicSplineInterpolant.prototype.interpolate_=function(e,t,r,a){const s=this.resultBuffer;var n=this.sampleValues,i=this.valueSize,o=2*i,l=3*i,c=a-t,a=(r-t)/c,r=a*a,t=r*a,u=e*l,d=u-l,h=-2*t+3*r,p=t-r,f=1-h,m=p-r+a;for(let e=0;e!==i;e++){var g=n[d+e+i],E=n[d+e+o]*c,v=n[u+e+i],T=n[u+e]*c;s[e]=f*g+m*E+h*v+p*T}return s};const s=new THREE.Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(e,t,r,a){e=super.interpolate_(e,t,r,a);return s.fromArray(e).normalize().toArray(e),e}}const f={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},T={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},o={9728:THREE.NearestFilter,9729:THREE.LinearFilter,9984:THREE.NearestMipmapNearestFilter,9985:THREE.LinearMipmapNearestFilter,9986:THREE.NearestMipmapLinearFilter,9987:THREE.LinearMipmapLinearFilter},c={33071:THREE.ClampToEdgeWrapping,33648:THREE.MirroredRepeatWrapping,10497:THREE.RepeatWrapping},y={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},m={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},R={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},x={CUBICSPLINE:void 0,LINEAR:THREE.InterpolateLinear,STEP:THREE.InterpolateDiscrete},d={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function addUnknownExtensionsToUserData(e,t,r){for(const a in r.extensions)void 0===e[a]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[a]=r.extensions[a])}function assignExtrasToUserData(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function createAttributesKey(r){let a="";var s=Object.keys(r).sort();for(let e=0,t=s.length;e<t;e++)a+=s[e]+":"+r[s[e]]+";";return a}function getNormalizedComponentScale(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class GLTFParser{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent)?this.textureLoader=new THREE.ImageBitmapLoader(this.options.manager):this.textureLoader=new THREE.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new THREE.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(r,e){const a=this,s=this.json,n=this.extensions;this.cache.removeAll(),this._invokeAll(function(e){return e._markDefs&&e._markDefs()}),Promise.all(this._invokeAll(function(e){return e.beforeRoot&&e.beforeRoot()})).then(function(){return Promise.all([a.getDependencies("scene"),a.getDependencies("animation"),a.getDependencies("camera")])}).then(function(e){const t={scene:e[0][s.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:s.asset,parser:a,userData:{}};addUnknownExtensionsToUserData(n,t,s),assignExtrasToUserData(t,s),Promise.all(a._invokeAll(function(e){return e.afterRoot&&e.afterRoot(t)})).then(function(){r(t)})}).catch(e)}_markDefs(){const r=this.json.nodes||[];var a=this.json.skins||[];const s=this.json.meshes||[];for(let e=0,t=a.length;e<t;e++){var n=a[e].joints;for(let e=0,t=n.length;e<t;e++)r[n[e]].isBone=!0}for(let e=0,t=r.length;e<t;e++){var i=r[e];void 0!==i.mesh&&(this._addNodeRef(this.meshCache,i.mesh),void 0!==i.skin&&(s[i.mesh].isSkinnedMesh=!0)),void 0!==i.camera&&this._addNodeRef(this.cameraCache,i.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,r){if(e.refs[t]<=1)return r;const a=r.clone(),n=(e,t)=>{var r,a,s=this.associations.get(e);null!=s&&this.associations.set(t,s);for([r,a]of e.children.entries())n(a,t.children[r])};return n(r,a),a.name+="_instance_"+e.uses[t]++,a}_invokeOne(t){const r=Object.values(this.plugins);r.push(this);for(let e=0;e<r.length;e++){var a=t(r[e]);if(a)return a}return null}_invokeAll(t){const r=Object.values(this.plugins),a=(r.unshift(this),[]);for(let e=0;e<r.length;e++){var s=t(r[e]);s&&a.push(s)}return a}getDependency(e,t){var r=e+":"+t;let a=this.cache.get(r);if(!a){switch(e){case"scene":a=this.loadScene(t);break;case"node":a=this.loadNode(t);break;case"mesh":a=this._invokeOne(function(e){return e.loadMesh&&e.loadMesh(t)});break;case"accessor":a=this.loadAccessor(t);break;case"bufferView":a=this._invokeOne(function(e){return e.loadBufferView&&e.loadBufferView(t)});break;case"buffer":a=this.loadBuffer(t);break;case"material":a=this._invokeOne(function(e){return e.loadMaterial&&e.loadMaterial(t)});break;case"texture":a=this._invokeOne(function(e){return e.loadTexture&&e.loadTexture(t)});break;case"skin":a=this.loadSkin(t);break;case"animation":a=this.loadAnimation(t);break;case"camera":a=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(r,a)}return a}getDependencies(r){let e=this.cache.get(r);if(!e){const a=this,t=this.json[r+("mesh"===r?"es":"s")]||[];e=Promise.all(t.map(function(e,t){return a.getDependency(r,t)})),this.cache.add(r,e)}return e}loadBuffer(e){const r=this.json.buffers[e],a=this.fileLoader;if(r.type&&"arraybuffer"!==r.type)throw new Error("THREE.GLTFLoader: "+r.type+" buffer type is not supported.");if(void 0===r.uri&&0===e)return Promise.resolve(this.extensions[h.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(e,t){a.load(THREE.LoaderUtils.resolveURL(r.uri,s.path),e,void 0,function(){t(new Error('THREE.GLTFLoader: Failed to load buffer "'+r.uri+'".'))})})}loadBufferView(e){const a=this.json.bufferViews[e];return this.getDependency("buffer",a.buffer).then(function(e){var t=a.byteLength||0,r=a.byteOffset||0;return e.slice(r,r+t)})}loadAccessor(e){const g=this,E=this.json,v=this.json.accessors[e];if(void 0===v.bufferView&&void 0===v.sparse)return Promise.resolve(null);const t=[];return void 0!==v.bufferView?t.push(this.getDependency("bufferView",v.bufferView)):t.push(null),void 0!==v.sparse&&(t.push(this.getDependency("bufferView",v.sparse.indices.bufferView)),t.push(this.getDependency("bufferView",v.sparse.values.bufferView))),Promise.all(t).then(function(e){var t=e[0],r=y[v.type];const a=T[v.componentType];var s=a.BYTES_PER_ELEMENT,n=s*r,i=v.byteOffset||0,o=void 0!==v.bufferView?E.bufferViews[v.bufferView].byteStride:void 0,l=!0===v.normalized;let c,u;if(o&&o!==n){var n=Math.floor(i/o),d="InterleavedBuffer:"+v.bufferView+":"+v.componentType+":"+n+":"+v.count;let e=g.cache.get(d);e||(c=new a(t,n*o,v.count*o/s),e=new THREE.InterleavedBuffer(c,o/s),g.cache.add(d,e)),u=new THREE.InterleavedBufferAttribute(e,r,i%o/s,l)}else c=null===t?new a(v.count*r):new a(t,i,v.count*r),u=new THREE.BufferAttribute(c,r,l);if(void 0!==v.sparse){n=y.SCALAR;const m=T[v.sparse.indices.componentType];var d=v.sparse.indices.byteOffset||0,o=v.sparse.values.byteOffset||0,h=new m(e[1],d,v.sparse.count*n),p=new a(e[2],o,v.sparse.count*r);null!==t&&(u=new THREE.BufferAttribute(u.array.slice(),u.itemSize,u.normalized));for(let e=0,t=h.length;e<t;e++){var f=h[e];if(u.setX(f,p[e*r]),2<=r&&u.setY(f,p[e*r+1]),3<=r&&u.setZ(f,p[e*r+2]),4<=r&&u.setW(f,p[e*r+3]),5<=r)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")}}return u})}loadTexture(e){var t=this.json;const r=this.options;var a=t.textures[e].source,t=t.images[a];let s=this.textureLoader;return t.uri&&null!==(t=r.manager.getHandler(t.uri))&&(s=t),this.loadTextureImage(e,a,s)}loadTextureImage(r,e,t){const a=this,s=this.json,n=s.textures[r];var i=s.images[e],i=(i.uri||i.bufferView)+":"+n.sampler;if(this.textureCache[i])return this.textureCache[i];e=this.loadImageSource(e,t).then(function(e){e.flipY=!1,n.name&&(e.name=n.name);var t=(s.samplers||{})[n.sampler]||{};return e.magFilter=o[t.magFilter]||THREE.LinearFilter,e.minFilter=o[t.minFilter]||THREE.LinearMipmapLinearFilter,e.wrapS=c[t.wrapS]||THREE.RepeatWrapping,e.wrapT=c[t.wrapT]||THREE.RepeatWrapping,a.associations.set(e,{textures:r}),e}).catch(function(){return null});return this.textureCache[i]=e}loadImageSource(e,s){var t=this.json;const n=this.options;if(void 0!==this.sourceCache[e])return this.sourceCache[e].then(function(e){return e.clone()}).catch(function(e){throw e});const r=t.images[e],a=self.URL||self.webkitURL;let i=r.uri||"",o=!1;if(void 0!==r.bufferView)i=this.getDependency("bufferView",r.bufferView).then(function(e){o=!0;e=new Blob([e],{type:r.mimeType});return i=a.createObjectURL(e)});else if(void 0===r.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");t=Promise.resolve(i).then(function(a){return new Promise(function(r,e){let t=r;!0===s.isImageBitmapLoader&&(t=function(e){const t=new THREE.Texture(e);t.needsUpdate=!0,r(t)}),s.load(THREE.LoaderUtils.resolveURL(a,n.path),t,void 0,e)})}).then(function(e){return!0===o&&a.revokeObjectURL(i),e.userData.mimeType=r.mimeType||function getImageURIMimeType(e){return 0<e.search(/\.jpe?g($|\?)/i)||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":0<e.search(/\.webp($|\?)/i)||0===e.search(/^data\:image\/webp/)?"image/webp":"image/png"}(r.uri),e}).catch(function(e){throw console.error("THREE.GLTFLoader: Couldn't load texture",i),e});return this.sourceCache[e]=t}assignTexture(a,s,n){const i=this;return this.getDependency("texture",n.index).then(function(e){var t,r;return void 0===n.texCoord||0==n.texCoord||"aoMap"===s&&1==n.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+s+" not yet supported."),i.extensions[h.KHR_TEXTURE_TRANSFORM]&&(t=void 0!==n.extensions?n.extensions[h.KHR_TEXTURE_TRANSFORM]:void 0)&&(r=i.associations.get(e),e=i.extensions[h.KHR_TEXTURE_TRANSFORM].extendTexture(e,t),i.associations.set(e,r)),a[s]=e})}assignFinalMaterial(e){const t=e.geometry;let r=e.material;var a=void 0===t.attributes.tangent,s=void 0!==t.attributes.color,n=void 0===t.attributes.normal;if(e.isPoints){var i="PointsMaterial:"+r.uuid;let e=this.cache.get(i);e||(e=new THREE.PointsMaterial,THREE.Material.prototype.copy.call(e,r),e.color.copy(r.color),e.map=r.map,e.sizeAttenuation=!1,this.cache.add(i,e)),r=e}else if(e.isLine){i="LineBasicMaterial:"+r.uuid;let e=this.cache.get(i);e||(e=new THREE.LineBasicMaterial,THREE.Material.prototype.copy.call(e,r),e.color.copy(r.color),this.cache.add(i,e)),r=e}if(a||s||n){let e="ClonedMaterial:"+r.uuid+":",t=(r.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),a&&(e+="derivative-tangents:"),s&&(e+="vertex-colors:"),n&&(e+="flat-shading:"),this.cache.get(e));t||(t=r.clone(),s&&(t.vertexColors=!0),n&&(t.flatShading=!0),a&&(t.normalScale&&(t.normalScale.y*=-1),t.clearcoatNormalScale&&(t.clearcoatNormalScale.y*=-1)),this.cache.add(e,t),this.associations.set(t,this.associations.get(r))),r=t}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=r}getMaterialType(){return THREE.MeshStandardMaterial}loadMaterial(t){const r=this;var e=this.json;const a=this.extensions,s=e.materials[t];let n;const i={};e=s.extensions||{};const o=[];if(e[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const c=a[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];n=c.getMaterialType(),o.push(c.extendParams(i,s,r))}else if(e[h.KHR_MATERIALS_UNLIT]){const u=a[h.KHR_MATERIALS_UNLIT];n=u.getMaterialType(),o.push(u.extendParams(i,s,r))}else{e=s.pbrMetallicRoughness||{};i.color=new THREE.Color(1,1,1),i.opacity=1,Array.isArray(e.baseColorFactor)&&(l=e.baseColorFactor,i.color.fromArray(l),i.opacity=l[3]),void 0!==e.baseColorTexture&&o.push(r.assignTexture(i,"map",e.baseColorTexture)),i.metalness=void 0!==e.metallicFactor?e.metallicFactor:1,i.roughness=void 0!==e.roughnessFactor?e.roughnessFactor:1,void 0!==e.metallicRoughnessTexture&&(o.push(r.assignTexture(i,"metalnessMap",e.metallicRoughnessTexture)),o.push(r.assignTexture(i,"roughnessMap",e.metallicRoughnessTexture))),n=this._invokeOne(function(e){return e.getMaterialType&&e.getMaterialType(t)}),o.push(Promise.all(this._invokeAll(function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,i)})))}!0===s.doubleSided&&(i.side=THREE.DoubleSide);var l=s.alphaMode||d.OPAQUE;return l===d.BLEND?(i.transparent=!0,i.depthWrite=!1):(i.transparent=!1,l===d.MASK&&(i.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&n!==THREE.MeshBasicMaterial&&(o.push(r.assignTexture(i,"normalMap",s.normalTexture)),i.normalScale=new THREE.Vector2(1,1),void 0!==s.normalTexture.scale&&(e=s.normalTexture.scale,i.normalScale.set(e,e))),void 0!==s.occlusionTexture&&n!==THREE.MeshBasicMaterial&&(o.push(r.assignTexture(i,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(i.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&n!==THREE.MeshBasicMaterial&&(i.emissive=(new THREE.Color).fromArray(s.emissiveFactor)),void 0!==s.emissiveTexture&&n!==THREE.MeshBasicMaterial&&o.push(r.assignTexture(i,"emissiveMap",s.emissiveTexture)),Promise.all(o).then(function(){let e;return e=n===GLTFMeshStandardSGMaterial?a[h.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(i):new n(i),s.name&&(e.name=s.name),e.map&&(e.map.encoding=THREE.sRGBEncoding),e.emissiveMap&&(e.emissiveMap.encoding=THREE.sRGBEncoding),assignExtrasToUserData(e,s),r.associations.set(e,{materials:t}),s.extensions&&addUnknownExtensionsToUserData(a,e,s),e})}createUniqueName(e){var t=THREE.PropertyBinding.sanitizeNodeName(e||"");let r=t;for(let e=1;this.nodeNamesUsed[r];++e)r=t+"_"+e;return this.nodeNamesUsed[r]=!0,r}loadGeometries(r){const a=this,s=this.extensions,n=this.primitiveCache;const i=[];for(let e=0,t=r.length;e<t;e++){var o=r[e],l=function createPrimitiveKey(e){var t=e.extensions&&e.extensions[h.KHR_DRACO_MESH_COMPRESSION];let r;return r=t?"draco:"+t.bufferView+":"+t.indices+":"+createAttributesKey(t.attributes):e.indices+":"+createAttributesKey(e.attributes)+":"+e.mode}(o),c=n[l];if(c)i.push(c.promise);else{let e;e=o.extensions&&o.extensions[h.KHR_DRACO_MESH_COMPRESSION]?function createDracoPrimitive(t){return s[h.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,a).then(function(e){return addPrimitiveAttributes(e,t,a)})}(o):addPrimitiveAttributes(new THREE.BufferGeometry,o,a),n[l]={primitive:o,promise:e},i.push(e)}}return Promise.all(i)}loadMesh(c){const u=this;var e=this.json;const d=this.extensions,h=e.meshes[c],p=h.primitives,r=[];for(let e=0,t=p.length;e<t;e++){var a=void 0===p[e].material?function createDefaultMaterial(e){return void 0===e.DefaultMaterial&&(e.DefaultMaterial=new THREE.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:THREE.FrontSide})),e.DefaultMaterial}(this.cache):this.getDependency("material",p[e].material);r.push(a)}return r.push(u.loadGeometries(p)),Promise.all(r).then(function(e){var r=e.slice(0,e.length-1),a=e[e.length-1];const s=[];for(let t=0,e=a.length;t<e;t++){var n=a[t],i=p[t];let e;var o=r[t];if(i.mode===f.TRIANGLES||i.mode===f.TRIANGLE_STRIP||i.mode===f.TRIANGLE_FAN||void 0===i.mode)!0!==(e=new(!0===h.isSkinnedMesh?THREE.SkinnedMesh:THREE.Mesh)(n,o)).isSkinnedMesh||e.geometry.attributes.skinWeight.normalized||e.normalizeSkinWeights(),i.mode===f.TRIANGLE_STRIP?e.geometry=toTrianglesDrawMode(e.geometry,THREE.TriangleStripDrawMode):i.mode===f.TRIANGLE_FAN&&(e.geometry=toTrianglesDrawMode(e.geometry,THREE.TriangleFanDrawMode));else if(i.mode===f.LINES)e=new THREE.LineSegments(n,o);else if(i.mode===f.LINE_STRIP)e=new THREE.Line(n,o);else if(i.mode===f.LINE_LOOP)e=new THREE.LineLoop(n,o);else{if(i.mode!==f.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+i.mode);e=new THREE.Points(n,o)}0<Object.keys(e.geometry.morphAttributes).length&&!function updateMorphTargets(r,a){if(r.updateMorphTargets(),void 0!==a.weights)for(let e=0,t=a.weights.length;e<t;e++)r.morphTargetInfluences[e]=a.weights[e];if(a.extras&&Array.isArray(a.extras.targetNames)){var s=a.extras.targetNames;if(r.morphTargetInfluences.length===s.length){r.morphTargetDictionary={};for(let e=0,t=s.length;e<t;e++)r.morphTargetDictionary[s[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}(e,h),e.name=u.createUniqueName(h.name||"mesh_"+c),assignExtrasToUserData(e,h),i.extensions&&addUnknownExtensionsToUserData(d,e,i),u.assignFinalMaterial(e),s.push(e)}for(let e=0,t=s.length;e<t;e++)u.associations.set(s[e],{meshes:c,primitives:e});if(1===s.length)return s[0];const l=new THREE.Group;u.associations.set(l,{meshes:c});for(let e=0,t=s.length;e<t;e++)l.add(s[e]);return l})}loadCamera(e){let t;var e=this.json.cameras[e],r=e[e.type];if(r)return"perspective"===e.type?t=new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):"orthographic"===e.type&&(t=new THREE.OrthographicCamera(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),e.name&&(t.name=this.createUniqueName(e.name)),assignExtrasToUserData(t,e),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){e=this.json.skins[e];const t={joints:e.joints};return void 0===e.inverseBindMatrices?Promise.resolve(t):this.getDependency("accessor",e.inverseBindMatrices).then(function(e){return t.inverseBindMatrices=e,t})}loadAnimation(t){const T=this.json.animations[t],r=[],a=[],s=[],n=[],i=[];for(let e=0,t=T.channels.length;e<t;e++){var o=T.channels[e],l=T.samplers[o.sampler],o=o.target,c=void 0!==o.node?o.node:o.id,u=void 0!==T.parameters?T.parameters[l.input]:l.input,d=void 0!==T.parameters?T.parameters[l.output]:l.output;r.push(this.getDependency("node",c)),a.push(this.getDependency("accessor",u)),s.push(this.getDependency("accessor",d)),n.push(l),i.push(o)}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(s),Promise.all(n),Promise.all(i)]).then(function(e){var r=e[0],a=e[1],s=e[2],n=e[3],i=e[4];const o=[];for(let e=0,t=r.length;e<t;e++){const m=r[e];var l=a[e],c=s[e],u=n[e],d=i[e];if(void 0!==m){m.updateMatrix(),m.matrixAutoUpdate=!0;let r;switch(R[d.path]){case R.weights:r=THREE.NumberKeyframeTrack;break;case R.rotation:r=THREE.QuaternionKeyframeTrack;break;case R.position:case R.scale:default:r=THREE.VectorKeyframeTrack}var h=m.name||m.uuid,p=void 0!==u.interpolation?x[u.interpolation]:THREE.InterpolateLinear;const g=[];R[d.path]===R.weights?m.traverse(function(e){e.morphTargetInfluences&&g.push(e.name||e.uuid)}):g.push(h);let a=c.array;if(c.normalized){var f=getNormalizedComponentScale(a.constructor);const E=new Float32Array(a.length);for(let e=0,t=a.length;e<t;e++)E[e]=a[e]*f;a=E}for(let e=0,t=g.length;e<t;e++){const v=new r(g[e]+"."+R[d.path],l.array,a,p);"CUBICSPLINE"===u.interpolation&&(v.createInterpolant=function InterpolantFactoryMethodGLTFCubicSpline(e){const t=this instanceof THREE.QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new t(this.times,this.values,this.getValueSize()/3,e)},v.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),o.push(v)}}}e=T.name||"animation_"+t;return new THREE.AnimationClip(e,void 0,o)})}createNodeMesh(e){var t=this.json;const r=this,a=t.nodes[e];return void 0===a.mesh?null:r.getDependency("mesh",a.mesh).then(function(e){const t=r._getNodeRef(r.meshCache,a.mesh,e);return void 0!==a.weights&&t.traverse(function(r){if(r.isMesh)for(let e=0,t=a.weights.length;e<t;e++)r.morphTargetInfluences[e]=a.weights[e]}),t})}loadNode(s){var e=this.json;const t=this.extensions,n=this,i=e.nodes[s],o=i.name?n.createUniqueName(i.name):"";return function(){const t=[];var e=n._invokeOne(function(e){return e.createNodeMesh&&e.createNodeMesh(s)});return e&&t.push(e),void 0!==i.camera&&t.push(n.getDependency("camera",i.camera).then(function(e){return n._getNodeRef(n.cameraCache,i.camera,e)})),n._invokeAll(function(e){return e.createNodeAttachment&&e.createNodeAttachment(s)}).forEach(function(e){t.push(e)}),Promise.all(t)}().then(function(r){let a;if((a=!0===i.isBone?new THREE.Bone:1<r.length?new THREE.Group:1===r.length?r[0]:new THREE.Object3D)!==r[0])for(let e=0,t=r.length;e<t;e++)a.add(r[e]);if(i.name&&(a.userData.name=i.name,a.name=o),assignExtrasToUserData(a,i),i.extensions&&addUnknownExtensionsToUserData(t,a,i),void 0!==i.matrix){const e=new THREE.Matrix4;e.fromArray(i.matrix),a.applyMatrix4(e)}else void 0!==i.translation&&a.position.fromArray(i.translation),void 0!==i.rotation&&a.quaternion.fromArray(i.rotation),void 0!==i.scale&&a.scale.fromArray(i.scale);return n.associations.has(a)||n.associations.set(a,{}),n.associations.get(a).nodes=s,a})}loadScene(e){var r=this.json,t=this.extensions,e=this.json.scenes[e];const s=this,a=new THREE.Group;e.name&&(a.name=s.createUniqueName(e.name)),assignExtrasToUserData(a,e),e.extensions&&addUnknownExtensionsToUserData(t,a,e);var n=e.nodes||[];const i=[];for(let e=0,t=n.length;e<t;e++)i.push(function buildNodeHierarchy(e,t,i,l){const c=i.nodes[e];return l.getDependency("node",e).then(function(e){if(void 0===c.skin)return e;let o;return l.getDependency("skin",c.skin).then(function(e){o=e;const r=[];for(let e=0,t=o.joints.length;e<t;e++)r.push(l.getDependency("node",o.joints[e]));return Promise.all(r)}).then(function(i){return e.traverse(function(e){if(e.isMesh){const r=[],a=[];for(let e=0,t=i.length;e<t;e++){const s=i[e];if(s){r.push(s);const n=new THREE.Matrix4;void 0!==o.inverseBindMatrices&&n.fromArray(o.inverseBindMatrices.array,16*e),a.push(n)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[e])}e.bind(new THREE.Skeleton(r,a),e.matrixWorld)}}),e})}).then(function(r){t.add(r);const a=[];if(c.children){const s=c.children;for(let e=0,t=s.length;e<t;e++){const n=s[e];a.push(buildNodeHierarchy(n,r,i,l))}}return Promise.all(a)})}(n[e],a,r,s));return Promise.all(i).then(function(){return s.associations=(e=>{const r=new Map;for(var[t,a]of s.associations)(t instanceof THREE.Material||t instanceof THREE.Texture)&&r.set(t,a);return e.traverse(e=>{var t=s.associations.get(e);null!=t&&r.set(e,t)}),r})(a),a})}}function addPrimitiveAttributes(r,e,a){var t,s=e.attributes;const n=[];for(const o in s){var i=m[o]||o.toLowerCase();i in r.attributes||n.push(function assignAttributeAccessor(e,t){return a.getDependency("accessor",e).then(function(e){r.setAttribute(t,e)})}(s[o],i))}return void 0===e.indices||r.index||(t=a.getDependency("accessor",e.indices).then(function(e){r.setIndex(e)}),n.push(t)),assignExtrasToUserData(r,e),function computeBounds(e,t,r){var a=t.attributes;const s=new THREE.Box3;if(void 0!==a.POSITION){var a=r.json.accessors[a.POSITION],n=a.min,i=a.max;if(void 0===n||void 0===i)console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");else{s.set(new THREE.Vector3(n[0],n[1],n[2]),new THREE.Vector3(i[0],i[1],i[2])),a.normalized&&(n=getNormalizedComponentScale(T[a.componentType]),s.min.multiplyScalar(n),s.max.multiplyScalar(n));var o=t.targets;if(void 0!==o){const h=new THREE.Vector3,p=new THREE.Vector3;for(let e=0,t=o.length;e<t;e++){var l,c,u=o[e];void 0!==u.POSITION&&(c=(u=r.json.accessors[u.POSITION]).min,l=u.max,void 0!==c&&void 0!==l?(p.setX(Math.max(Math.abs(c[0]),Math.abs(l[0]))),p.setY(Math.max(Math.abs(c[1]),Math.abs(l[1]))),p.setZ(Math.max(Math.abs(c[2]),Math.abs(l[2]))),u.normalized&&(c=getNormalizedComponentScale(T[u.componentType]),p.multiplyScalar(c)),h.max(p)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION."))}s.expandByVector(h)}e.boundingBox=s;const d=new THREE.Sphere;s.getCenter(d.center),d.radius=s.min.distanceTo(s.max)/2,e.boundingSphere=d}}}(r,e,a),Promise.all(n).then(function(){return void 0!==e.targets?function addMorphTargets(a,r,s){let n=!1,i=!1,o=!1;for(let e=0,t=r.length;e<t;e++){var l=r[e];if(void 0!==l.POSITION&&(n=!0),void 0!==l.NORMAL&&(i=!0),void 0!==l.COLOR_0&&(o=!0),n&&i&&o)break}if(!n&&!i&&!o)return Promise.resolve(a);const c=[],u=[],d=[];for(let e=0,t=r.length;e<t;e++){var h,p=r[e];n&&(h=void 0!==p.POSITION?s.getDependency("accessor",p.POSITION):a.attributes.position,c.push(h)),i&&(h=void 0!==p.NORMAL?s.getDependency("accessor",p.NORMAL):a.attributes.normal,u.push(h)),o&&(p=void 0!==p.COLOR_0?s.getDependency("accessor",p.COLOR_0):a.attributes.color,d.push(p))}return Promise.all([Promise.all(c),Promise.all(u),Promise.all(d)]).then(function(e){var t=e[0],r=e[1],e=e[2];return n&&(a.morphAttributes.position=t),i&&(a.morphAttributes.normal=r),o&&(a.morphAttributes.color=e),a.morphTargetsRelative=!0,a})}(r,e.targets,a):r})}function toTrianglesDrawMode(e,t){let r=e.getIndex();if(null===r){const o=[];var a=e.getAttribute("position");if(void 0===a)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<a.count;e++)o.push(e);e.setIndex(o),r=e.getIndex()}var s=r.count-2;const n=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=s;e++)n.push(r.getX(0)),n.push(r.getX(e)),n.push(r.getX(e+1));else for(let e=0;e<s;e++)e%2==0?(n.push(r.getX(e)),n.push(r.getX(e+1)),n.push(r.getX(e+2))):(n.push(r.getX(e+2)),n.push(r.getX(e+1)),n.push(r.getX(e)));n.length/3!=s&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i}THREE.GLTFLoader=GLTFLoader}();{let u,d,c;class FBXLoader extends THREE.Loader{constructor(e){super(e)}load(t,r,e,a){const s=this,n=""===s.path?THREE.LoaderUtils.extractUrlBase(t):s.path,i=new THREE.FileLoader(this.manager);i.setPath(s.path),i.setResponseType("arraybuffer"),i.setRequestHeader(s.requestHeader),i.setWithCredentials(s.withCredentials),i.load(t,function(e){try{r(s.parse(e,n))}catch(e){a?a(e):console.error(e),s.manager.itemError(t)}},e,a)}parse(e,t){if(function isFbxFormatBinary(e){var t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===convertArrayBufferToString(e,0,t.length)}(e))u=(new BinaryParser).parse(e);else{e=convertArrayBufferToString(e);if(!function isFbxFormatASCII(r){var t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let a=0;for(let e=0;e<t.length;++e)if(function read(e){var t=r[e-1];return r=r.slice(a+e),a++,t}(1)===t[e])return;return 1}(e))throw new Error("THREE.FBXLoader: Unknown format.");if(getFbxVersion(e)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+getFbxVersion(e));u=(new TextParser).parse(e)}e=new THREE.TextureLoader(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new FBXTreeParser(e,this.manager).parse(u)}}class FBXTreeParser{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){d=this.parseConnections();var e=this.parseImages(),e=this.parseTextures(e),e=this.parseMaterials(e),t=this.parseDeformers(),r=(new GeometryParser).parse(t);return this.parseScene(t,r,e),c}parseConnections(){const s=new Map;if("Connections"in u){const e=u.Connections.connections;e.forEach(function(e){var t=e[0],r=e[1],e=e[2],a=(s.has(t)||s.set(t,{parents:[],children:[]}),{ID:r,relationship:e}),a=(s.get(t).parents.push(a),s.has(r)||s.set(r,{parents:[],children:[]}),{ID:t,relationship:e});s.get(r).children.push(a)})}return s}parseImages(){const e={},t={};if("Video"in u.Objects){var r=u.Objects.Video;for(const o in r){var a,s=r[o],n=parseInt(o);e[n]=s.RelativeFilename||s.Filename,"Content"in s&&(n=s.Content instanceof ArrayBuffer&&0<s.Content.byteLength,a="string"==typeof s.Content&&""!==s.Content,(n||a)&&(n=this.parseImage(r[o]),t[s.RelativeFilename||s.Filename]=n))}}for(const l in e){var i=e[l];void 0!==t[i]?e[l]=t[i]:e[l]=e[l].split("\\").pop()}return e}parseImage(e){var t=e.Content;const r=e.RelativeFilename||e.Filename;var a=r.slice(r.lastIndexOf(".")+1).toLowerCase();let s;switch(a){case"bmp":s="image/bmp";break;case"jpg":case"jpeg":s="image/jpeg";break;case"png":s="image/png";break;case"tif":s="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",r),s="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+a+'" is not supported.')}return"string"==typeof t?"data:"+s+";base64,"+t:(e=new Uint8Array(t),window.URL.createObjectURL(new Blob([e],{type:s})))}parseTextures(e){const t=new Map;if("Texture"in u.Objects){var r=u.Objects.Texture;for(const s in r){var a=this.parseTexture(r[s],e);t.set(parseInt(s),a)}}return t}parseTexture(e,t){const r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;var t=e.WrapModeU,a=e.WrapModeV,t=void 0!==t?t.value:0,a=void 0!==a?a.value:0;return r.wrapS=0===t?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,r.wrapT=0===a?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,"Scaling"in e&&(t=e.Scaling.value,r.repeat.x=t[0],r.repeat.y=t[1]),r}loadTexture(e,t){let r;var a=this.textureLoader.path,s=d.get(e.id).children;void 0!==s&&0<s.length&&void 0!==t[s[0].ID]&&(0!==(r=t[s[0].ID]).indexOf("blob:")&&0!==r.indexOf("data:")||this.textureLoader.setPath(void 0));let n;t=e.FileName.slice(-3).toLowerCase();if("tga"===t){const i=this.manager.getHandler(".tga");n=null===i?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),new THREE.Texture):(i.setPath(this.textureLoader.path),i.load(r))}else n="psd"===t?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),new THREE.Texture):this.textureLoader.load(r);return this.textureLoader.setPath(a),n}parseMaterials(e){const t=new Map;if("Material"in u.Objects){var r=u.Objects.Material;for(const s in r){var a=this.parseMaterial(r[s],e);null!==a&&t.set(parseInt(s),a)}}return t}parseMaterial(e,t){var r=e.id,a=e.attrName;let s=e.ShadingModel;if("object"==typeof s&&(s=s.value),!d.has(r))return null;e=this.parseParameters(e,t,r);let n;switch(s.toLowerCase()){case"phong":n=new THREE.MeshPhongMaterial;break;case"lambert":n=new THREE.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to THREE.MeshPhongMaterial.',s),n=new THREE.MeshPhongMaterial}return n.setValues(e),n.name=a,n}parseParameters(e,r,t){const a={},s=(e.BumpFactor&&(a.bumpScale=e.BumpFactor.value),e.Diffuse?a.color=(new THREE.Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(a.color=(new THREE.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(a.displacementScale=e.DisplacementFactor.value),e.Emissive?a.emissive=(new THREE.Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(a.emissive=(new THREE.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(a.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(a.opacity=parseFloat(e.Opacity.value)),a.opacity<1&&(a.transparent=!0),e.ReflectionFactor&&(a.reflectivity=e.ReflectionFactor.value),e.Shininess&&(a.shininess=e.Shininess.value),e.Specular?a.specular=(new THREE.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(a.specular=(new THREE.Color).fromArray(e.SpecularColor.value)),this);return d.get(t).children.forEach(function(e){var t=e.relationship;switch(t){case"Bump":a.bumpMap=s.getTexture(r,e.ID);break;case"Maya|TEX_ao_map":a.aoMap=s.getTexture(r,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":a.map=s.getTexture(r,e.ID),void 0!==a.map&&(a.map.encoding=THREE.sRGBEncoding);break;case"DisplacementColor":a.displacementMap=s.getTexture(r,e.ID);break;case"EmissiveColor":a.emissiveMap=s.getTexture(r,e.ID),void 0!==a.emissiveMap&&(a.emissiveMap.encoding=THREE.sRGBEncoding);break;case"NormalMap":case"Maya|TEX_normal_map":a.normalMap=s.getTexture(r,e.ID);break;case"ReflectionColor":a.envMap=s.getTexture(r,e.ID),void 0!==a.envMap&&(a.envMap.mapping=THREE.EquirectangularReflectionMapping,a.envMap.encoding=THREE.sRGBEncoding);break;case"SpecularColor":a.specularMap=s.getTexture(r,e.ID),void 0!==a.specularMap&&(a.specularMap.encoding=THREE.sRGBEncoding);break;case"TransparentColor":case"TransparencyFactor":a.alphaMap=s.getTexture(r,e.ID),a.transparent=!0;break;default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}}),a}getTexture(e,t){return"LayeredTexture"in u.Objects&&t in u.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=d.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in u.Objects){var r=u.Objects.Deformer;for(const n in r){var a=r[n],s=d.get(parseInt(n));if("Skin"===a.attrType){const i=this.parseSkeleton(s,r);i.ID=n,1<s.parents.length&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),i.geometryID=s.parents[0].ID,e[n]=i}else if("BlendShape"===a.attrType){const o={id:n};o.rawTargets=this.parseMorphTargets(s,r),o.id=n,1<s.parents.length&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=o}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,a){const s=[];return e.children.forEach(function(e){var t=a[e.ID];if("Cluster"===t.attrType){const r={ID:e.ID,indices:[],weights:[],transformLink:(new THREE.Matrix4).fromArray(t.TransformLink.a)};"Indexes"in t&&(r.indices=t.Indexes.a,r.weights=t.Weights.a),s.push(r)}}),{rawBones:s,bones:[]}}parseMorphTargets(t,r){const a=[];for(let e=0;e<t.children.length;e++){var s=t.children[e],n=r[s.ID];const i={name:n.attrName,initialWeight:n.DeformPercent,id:n.id,fullWeights:n.FullWeights.a};if("BlendShapeChannel"!==n.attrType)return;i.geoID=d.get(parseInt(s.ID)).children.filter(function(e){return void 0===e.relationship})[0].ID,a.push(i)}return a}parseScene(e,t,r){c=new THREE.Group;const a=this.parseModels(e.skeletons,t,r),s=u.Objects.Model,n=this;a.forEach(function(r){var e=s[r.ID];n.setLookAtProperties(r,e);const t=d.get(r.ID).parents;t.forEach(function(e){const t=a.get(e.ID);void 0!==t&&t.add(r)}),null===r.parent&&c.add(r)}),this.bindSkeleton(e.skeletons,t,a),this.createAmbientLight(),c.traverse(function(e){var t;e.userData.transformData&&(e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld),t=generateTransform(e.userData.transformData),e.applyMatrix4(t),e.updateWorldMatrix())});r=(new AnimationParser).parse();1===c.children.length&&c.children[0].isGroup&&(c.children[0].animations=r,c=c.children[0]),c.animations=r}parseModels(t,r,a){const s=new Map;var n=u.Objects.Model;for(const c in n){var i=parseInt(c),o=n[c],l=d.get(i);let e=this.buildSkeleton(l,t,i,o.attrName);if(!e){switch(o.attrType){case"Camera":e=this.createCamera(l);break;case"Light":e=this.createLight(l);break;case"Mesh":e=this.createMesh(l,r,a);break;case"NurbsCurve":e=this.createCurve(l,r);break;case"LimbNode":case"Root":e=new THREE.Bone;break;default:e=new THREE.Group}e.name=o.attrName?THREE.PropertyBinding.sanitizeNodeName(o.attrName):"",e.ID=i}this.getTransformData(e,o),s.set(i,e)}return s}buildSkeleton(e,t,n,i){let o=null;return e.parents.forEach(function(a){for(const e in t){const s=t[e];s.rawBones.forEach(function(e,t){var r;e.ID===a.ID&&(r=o,(o=new THREE.Bone).matrixWorld.copy(e.transformLink),o.name=i?THREE.PropertyBinding.sanitizeNodeName(i):"",o.ID=n,s.bones[t]=o,null!==r&&o.add(r))})}}),o}createCamera(e){let i,o;if(e.children.forEach(function(e){e=u.Objects.NodeAttribute[e.ID];void 0!==e&&(o=e)}),void 0===o)i=new THREE.Object3D;else{let e=0,t=(void 0!==o.CameraProjectionType&&1===o.CameraProjectionType.value&&(e=1),1),r=(void 0!==o.NearPlane&&(t=o.NearPlane.value/1e3),1e3),a=(void 0!==o.FarPlane&&(r=o.FarPlane.value/1e3),window.innerWidth),s=window.innerHeight;void 0!==o.AspectWidth&&void 0!==o.AspectHeight&&(a=o.AspectWidth.value,s=o.AspectHeight.value);var l=a/s;let n=45;void 0!==o.FieldOfView&&(n=o.FieldOfView.value);var c=o.FocalLength?o.FocalLength.value:null;switch(e){case 0:i=new THREE.PerspectiveCamera(n,l,t,r),null!==c&&i.setFocalLength(c);break;case 1:i=new THREE.OrthographicCamera(-a/2,a/2,s/2,-s/2,t,r);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+e+"."),i=new THREE.Object3D}}return i}createLight(e){let i,o;if(e.children.forEach(function(e){e=u.Objects.NodeAttribute[e.ID];void 0!==e&&(o=e)}),void 0===o)i=new THREE.Object3D;else{let r,a=(r=void 0===o.LightType?0:o.LightType.value,16777215),s=(void 0!==o.Color&&(a=(new THREE.Color).fromArray(o.Color.value)),void 0===o.Intensity?1:o.Intensity.value/100),n=(void 0!==o.CastLightOnObject&&0===o.CastLightOnObject.value&&(s=0),0);void 0!==o.FarAttenuationEnd&&(n=void 0!==o.EnableFarAttenuation&&0===o.EnableFarAttenuation.value?0:o.FarAttenuationEnd.value);switch(r){case 0:i=new THREE.PointLight(a,s,n,1);break;case 1:i=new THREE.DirectionalLight(a,s);break;case 2:let e=Math.PI/3,t=(void 0!==o.InnerAngle&&(e=THREE.MathUtils.degToRad(o.InnerAngle.value)),0);void 0!==o.OuterAngle&&(t=THREE.MathUtils.degToRad(o.OuterAngle.value),t=Math.max(t,1)),i=new THREE.SpotLight(a,s,n,e,t,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+o.LightType.value+", defaulting to a THREE.PointLight."),i=new THREE.PointLight(a,s)}void 0!==o.CastShadows&&1===o.CastShadows.value&&(i.castShadow=!0)}return i}createMesh(e,t,r){let a,s=null,n=null;const i=[];return e.children.forEach(function(e){t.has(e.ID)&&(s=t.get(e.ID)),r.has(e.ID)&&i.push(r.get(e.ID))}),1<i.length?n=i:0<i.length?n=i[0]:(n=new THREE.MeshPhongMaterial({color:13421772}),i.push(n)),"color"in s.attributes&&i.forEach(function(e){e.vertexColors=!0}),s.FBX_Deformer?(a=new THREE.SkinnedMesh(s,n)).normalizeSkinWeights():a=new THREE.Mesh(s,n),a}createCurve(e,r){var e=e.children.reduce(function(e,t){return e=r.has(t.ID)?r.get(t.ID):e},null),t=new THREE.LineBasicMaterial({color:3342591,linewidth:1});return new THREE.Line(e,t)}getTransformData(e,t){const r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?r.eulerOrder=getEulerOrder(t.RotationOrder.value):r.eulerOrder="ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r}setLookAtProperties(t,e){if("LookAtProperty"in e){const r=d.get(t.ID).children;r.forEach(function(e){"LookAtProperty"===e.relationship&&"Lcl_Translation"in(e=u.Objects.Model[e.ID])&&(e=e.Lcl_Translation.value,void 0!==t.target?(t.target.position.fromArray(e),c.add(t.target)):t.lookAt((new THREE.Vector3).fromArray(e)))})}}bindSkeleton(e,r,a){const s=this.parsePoseNodes();for(const t in e){const n=e[t],i=d.get(parseInt(n.ID)).parents;i.forEach(function(e){if(r.has(e.ID)){e=e.ID;const t=d.get(e);t.parents.forEach(function(e){if(a.has(e.ID)){const t=a.get(e.ID);t.bind(new THREE.Skeleton(n.bones),s[e.ID])}})}})}}parsePoseNodes(){const t={};if("Pose"in u.Objects){var e=u.Objects.Pose;for(const r in e)if("BindPose"===e[r].attrType&&0<e[r].NbPoseNodes){const a=e[r].PoseNode;Array.isArray(a)?a.forEach(function(e){t[e.Node]=(new THREE.Matrix4).fromArray(e.Matrix.a)}):t[a.Node]=(new THREE.Matrix4).fromArray(a.Matrix.a)}}return t}createAmbientLight(){var e,t,r;"GlobalSettings"in u&&"AmbientColor"in u.GlobalSettings&&(r=(t=u.GlobalSettings.AmbientColor.value)[0],e=t[1],t=t[2],0===r&&0===e&&0===t||(r=new THREE.Color(r,e,t),c.add(new THREE.AmbientLight(r,1))))}}class GeometryParser{parse(e){const t=new Map;if("Geometry"in u.Objects){var r=u.Objects.Geometry;for(const s in r){var a=d.get(parseInt(s)),a=this.parseGeometry(a,r[s],e);t.set(parseInt(s),a)}}return t}parseGeometry(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,r){const a=r.skeletons,s=[];var n=e.parents.map(function(e){return u.Objects.Model[e.ID]});if(0!==n.length){var i=e.children.reduce(function(e,t){return e=void 0!==a[t.ID]?a[t.ID]:e},null),e=(e.children.forEach(function(e){void 0!==r.morphTargets[e.ID]&&s.push(r.morphTargets[e.ID])}),n[0]);const o={};"RotationOrder"in e&&(o.eulerOrder=getEulerOrder(e.RotationOrder.value)),"InheritType"in e&&(o.inheritType=parseInt(e.InheritType.value)),"GeometricTranslation"in e&&(o.translation=e.GeometricTranslation.value),"GeometricRotation"in e&&(o.rotation=e.GeometricRotation.value),"GeometricScaling"in e&&(o.scale=e.GeometricScaling.value);n=generateTransform(o);return this.genGeometry(t,i,s,n)}}genGeometry(e,t,r,a){const s=new THREE.BufferGeometry;e.attrName&&(s.name=e.attrName);var n=this.parseGeoNode(e,t);const i=this.genBuffers(n),o=new THREE.Float32BufferAttribute(i.vertex,3);if(o.applyMatrix4(a),s.setAttribute("position",o),0<i.colors.length&&s.setAttribute("color",new THREE.Float32BufferAttribute(i.colors,3)),t&&(s.setAttribute("skinIndex",new THREE.Uint16BufferAttribute(i.weightsIndices,4)),s.setAttribute("skinWeight",new THREE.Float32BufferAttribute(i.vertexWeights,4)),s.FBX_Deformer=t),0<i.normal.length){var t=(new THREE.Matrix3).getNormalMatrix(a);const l=new THREE.Float32BufferAttribute(i.normal,3);l.applyNormalMatrix(t),s.setAttribute("normal",l)}if(i.uvs.forEach(function(e,t){let r="uv"+(t+1).toString();0===t&&(r="uv"),s.setAttribute(r,new THREE.Float32BufferAttribute(i.uvs[t],2))}),n.material&&"AllSame"!==n.material.mappingType){let r=i.materialIndex[0],a=0;i.materialIndex.forEach(function(e,t){e!==r&&(s.addGroup(a,t-a,r),r=e,a=t)}),0<s.groups.length&&((n=(t=s.groups[s.groups.length-1]).start+t.count)!==i.materialIndex.length&&s.addGroup(n,i.materialIndex.length-n,r)),0===s.groups.length&&s.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(s,e,r,a),s}parseGeoNode(t,e){const s={};if(s.vertexPositions=void 0!==t.Vertices?t.Vertices.a:[],s.vertexIndices=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],t.LayerElementColor&&(s.color=this.parseVertexColors(t.LayerElementColor[0])),t.LayerElementMaterial&&(s.material=this.parseMaterialIndices(t.LayerElementMaterial[0])),t.LayerElementNormal&&(s.normal=this.parseNormals(t.LayerElementNormal[0])),t.LayerElementUV){s.uv=[];let e=0;for(;t.LayerElementUV[e];)t.LayerElementUV[e].UV&&s.uv.push(this.parseUVs(t.LayerElementUV[e])),e++}return s.weightTable={},null!==e&&(s.skeleton=e).rawBones.forEach(function(r,a){r.indices.forEach(function(e,t){void 0===s.weightTable[e]&&(s.weightTable[e]=[]),s.weightTable[e].push({id:a,weight:r.weights[t]})})}),s}genBuffers(c){const u={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let d=0,h=0,p=!1,f=[],m=[],g=[],E=[],v=[],T=[];const y=this;return c.vertexIndices.forEach(function(r,a){let e,t=!1,n=(r<0&&(r^=-1,t=!0),[]),s=[];var i;if(f.push(3*r,3*r+1,3*r+2),c.color&&(i=getData(a,d,r,c.color),g.push(i[0],i[1],i[2])),c.skeleton){if(void 0!==c.weightTable[r]&&c.weightTable[r].forEach(function(e){s.push(e.weight),n.push(e.id)}),4<s.length){p||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),p=!0);const o=[0,0,0,0],l=[0,0,0,0];s.forEach(function(e,t){let a=e,s=n[t];l.forEach(function(e,t,r){a>e&&(r[t]=a,a=e,r=o[t],o[t]=s,s=r)})}),n=o,s=l}for(;s.length<4;)s.push(0),n.push(0);for(let e=0;e<4;++e)v.push(s[e]),T.push(n[e])}c.normal&&(i=getData(a,d,r,c.normal),m.push(i[0],i[1],i[2])),c.material&&"AllSame"!==c.material.mappingType&&(e=getData(a,d,r,c.material)[0]),c.uv&&c.uv.forEach(function(e,t){e=getData(a,d,r,e);void 0===E[t]&&(E[t]=[]),E[t].push(e[0]),E[t].push(e[1])}),h++,t&&(y.genFace(u,c,f,e,m,g,E,v,T,h),d++,h=0,f=[],m=[],g=[],E=[],v=[],T=[])}),u}genFace(a,e,t,s,n,i,o,l,c,u){for(let r=2;r<u;r++)a.vertex.push(e.vertexPositions[t[0]]),a.vertex.push(e.vertexPositions[t[1]]),a.vertex.push(e.vertexPositions[t[2]]),a.vertex.push(e.vertexPositions[t[3*(r-1)]]),a.vertex.push(e.vertexPositions[t[3*(r-1)+1]]),a.vertex.push(e.vertexPositions[t[3*(r-1)+2]]),a.vertex.push(e.vertexPositions[t[3*r]]),a.vertex.push(e.vertexPositions[t[3*r+1]]),a.vertex.push(e.vertexPositions[t[3*r+2]]),e.skeleton&&(a.vertexWeights.push(l[0]),a.vertexWeights.push(l[1]),a.vertexWeights.push(l[2]),a.vertexWeights.push(l[3]),a.vertexWeights.push(l[4*(r-1)]),a.vertexWeights.push(l[4*(r-1)+1]),a.vertexWeights.push(l[4*(r-1)+2]),a.vertexWeights.push(l[4*(r-1)+3]),a.vertexWeights.push(l[4*r]),a.vertexWeights.push(l[4*r+1]),a.vertexWeights.push(l[4*r+2]),a.vertexWeights.push(l[4*r+3]),a.weightsIndices.push(c[0]),a.weightsIndices.push(c[1]),a.weightsIndices.push(c[2]),a.weightsIndices.push(c[3]),a.weightsIndices.push(c[4*(r-1)]),a.weightsIndices.push(c[4*(r-1)+1]),a.weightsIndices.push(c[4*(r-1)+2]),a.weightsIndices.push(c[4*(r-1)+3]),a.weightsIndices.push(c[4*r]),a.weightsIndices.push(c[4*r+1]),a.weightsIndices.push(c[4*r+2]),a.weightsIndices.push(c[4*r+3])),e.color&&(a.colors.push(i[0]),a.colors.push(i[1]),a.colors.push(i[2]),a.colors.push(i[3*(r-1)]),a.colors.push(i[3*(r-1)+1]),a.colors.push(i[3*(r-1)+2]),a.colors.push(i[3*r]),a.colors.push(i[3*r+1]),a.colors.push(i[3*r+2])),e.material&&"AllSame"!==e.material.mappingType&&(a.materialIndex.push(s),a.materialIndex.push(s),a.materialIndex.push(s)),e.normal&&(a.normal.push(n[0]),a.normal.push(n[1]),a.normal.push(n[2]),a.normal.push(n[3*(r-1)]),a.normal.push(n[3*(r-1)+1]),a.normal.push(n[3*(r-1)+2]),a.normal.push(n[3*r]),a.normal.push(n[3*r+1]),a.normal.push(n[3*r+2])),e.uv&&e.uv.forEach(function(e,t){void 0===a.uvs[t]&&(a.uvs[t]=[]),a.uvs[t].push(o[t][0]),a.uvs[t].push(o[t][1]),a.uvs[t].push(o[t][2*(r-1)]),a.uvs[t].push(o[t][2*(r-1)+1]),a.uvs[t].push(o[t][2*r]),a.uvs[t].push(o[t][2*r+1])})}addMorphTargets(r,a,e,s){if(0!==e.length){r.morphTargetsRelative=!0,r.morphAttributes.position=[];const n=this;e.forEach(function(e){e.rawTargets.forEach(function(e){var t=u.Objects.Geometry[e.geoID];void 0!==t&&n.genMorphGeometry(r,a,t,s,e.name)})})}}genMorphGeometry(e,t,r,a,s){var t=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],n=void 0!==r.Vertices?r.Vertices.a:[],i=void 0!==r.Indexes?r.Indexes.a:[],o=3*e.attributes.position.count;const l=new Float32Array(o);for(let e=0;e<i.length;e++){var c=3*i[e];l[c]=n[3*e],l[1+c]=n[3*e+1],l[2+c]=n[3*e+2]}o={vertexIndices:t,vertexPositions:l},t=this.genBuffers(o);const u=new THREE.Float32BufferAttribute(t.vertex,3);u.name=s||r.attrName,u.applyMatrix4(a),e.morphAttributes.position.push(u)}parseNormals(e){var t=e.MappingInformationType,r=e.ReferenceInformationType,a=e.Normals.a;let s=[];return"IndexToDirect"===r&&("NormalIndex"in e?s=e.NormalIndex.a:"NormalsIndex"in e&&(s=e.NormalsIndex.a)),{dataSize:3,buffer:a,indices:s,mappingType:t,referenceType:r}}parseUVs(e){var t=e.MappingInformationType,r=e.ReferenceInformationType;let a=[];return{dataSize:2,buffer:e.UV.a,indices:a="IndexToDirect"===r?e.UVIndex.a:a,mappingType:t,referenceType:r}}parseVertexColors(e){var t=e.MappingInformationType,r=e.ReferenceInformationType;let a=[];return{dataSize:4,buffer:e.Colors.a,indices:a="IndexToDirect"===r?e.ColorIndex.a:a,mappingType:t,referenceType:r}}parseMaterialIndices(e){var t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};var a=e.Materials.a;const s=[];for(let e=0;e<a.length;++e)s.push(e);return{dataSize:1,buffer:a,indices:s,mappingType:t,referenceType:r}}parseNurbsGeometry(e){if(void 0===THREE.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new THREE.BufferGeometry;var t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new THREE.BufferGeometry;var r=t-1,t=e.KnotVector.a;const a=[];var s=e.Points.a;for(let e=0,t=s.length;e<t;e+=4)a.push((new THREE.Vector4).fromArray(s,e));let n,i;if("Closed"===e.Form)a.push(a[0]);else if("Periodic"===e.Form){n=r,i=t.length-1-n;for(let e=0;e<r;++e)a.push(a[e])}const o=new THREE.NURBSCurve(r,t,a,n,i);e=o.getPoints(12*a.length);return(new THREE.BufferGeometry).setFromPoints(e)}}class AnimationParser{parse(){const e=[];var t=this.parseClips();if(void 0!==t)for(const a in t){var r=t[a],r=this.addClip(r);e.push(r)}return e}parseClips(){var e;if(void 0!==u.Objects.AnimationCurve)return e=this.parseAnimationCurveNodes(),this.parseAnimationCurves(e),e=this.parseAnimationLayers(e),this.parseAnimStacks(e)}parseAnimationCurveNodes(){var e,t=u.Objects.AnimationCurveNode;const r=new Map;for(const a in t){const s=t[a];null!==s.attrName.match(/S|R|T|DeformPercent/)&&(e={id:s.id,attr:s.attrName,curves:{}},r.set(e.id,e))}return r}parseAnimationCurves(e){const t=u.Objects.AnimationCurve;for(const n in t){var r={id:t[n].id,times:t[n].KeyTime.a.map(convertFBXTimeToSeconds),values:t[n].KeyValueFloat.a},a=d.get(r.id);if(void 0!==a){var s=a.parents[0].ID;const i=a.parents[0].relationship;i.match(/X/)?e.get(s).curves.x=r:i.match(/Y/)?e.get(s).curves.y=r:i.match(/Z/)?e.get(s).curves.z=r:i.match(/d|DeformPercent/)&&e.has(s)&&(e.get(s).curves.morph=r)}}}parseAnimationLayers(o){var e=u.Objects.AnimationLayer;const t=new Map;for(const a in e){const l=[];var r=d.get(parseInt(a));if(void 0!==r){const s=r.children;s.forEach(function(e,t){if(o.has(e.ID)){var r,a=o.get(e.ID);if(void 0!==a.curves.x||void 0!==a.curves.y||void 0!==a.curves.z){if(void 0===l[t]){const s=d.get(e.ID).parents.filter(function(e){return void 0!==e.relationship})[0].ID;if(void 0!==s){const n=u.Objects.Model[s.toString()];if(void 0===n)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",e);const i={modelName:n.attrName?THREE.PropertyBinding.sanitizeNodeName(n.attrName):"",ID:n.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};c.traverse(function(e){e.ID===n.id&&(i.transform=e.matrix,e.userData.transformData&&(i.eulerOrder=e.userData.transformData.eulerOrder))}),i.transform||(i.transform=new THREE.Matrix4),"PreRotation"in n&&(i.preRotation=n.PreRotation.value),"PostRotation"in n&&(i.postRotation=n.PostRotation.value),l[t]=i}}l[t]&&(l[t][a.attr]=a)}else void 0!==a.curves.morph&&(void 0===l[t]&&(e=d.get(e.ID).parents.filter(function(e){return void 0!==e.relationship})[0].ID,r=d.get(e).parents[0].ID,r=d.get(r).parents[0].ID,r=d.get(r).parents[0].ID,r={modelName:(r=u.Objects.Model[r]).attrName?THREE.PropertyBinding.sanitizeNodeName(r.attrName):"",morphName:u.Objects.Deformer[e].attrName},l[t]=r),l[t][a.attr]=a)}}),t.set(parseInt(a),l)}}return t}parseAnimStacks(e){var t=u.Objects.AnimationStack;const r={};for(const s in t){var a=d.get(parseInt(s)).children,a=(1<a.length&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."),e.get(a[0].ID));r[s]={name:t[s].attrName,layer:a}}return r}addClip(e){let t=[];const r=this;return e.layer.forEach(function(e){t=t.concat(r.generateTracks(e))}),new THREE.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let r=new THREE.Vector3,a=new THREE.Quaternion,s=new THREE.Vector3;var n;return e.transform&&e.transform.decompose(r,a,s),r=r.toArray(),a=(new THREE.Euler).setFromQuaternion(a,e.eulerOrder).toArray(),s=s.toArray(),void 0!==e.T&&0<Object.keys(e.T.curves).length&&(void 0!==(n=this.generateVectorTrack(e.modelName,e.T.curves,r,"position"))&&t.push(n)),void 0!==e.R&&0<Object.keys(e.R.curves).length&&(void 0!==(n=this.generateRotationTrack(e.modelName,e.R.curves,a,e.preRotation,e.postRotation,e.eulerOrder))&&t.push(n)),void 0!==e.S&&0<Object.keys(e.S.curves).length&&(void 0!==(n=this.generateVectorTrack(e.modelName,e.S.curves,s,"scale"))&&t.push(n)),void 0!==e.DeformPercent&&void 0!==(n=this.generateMorphTrack(e))&&t.push(n),t}generateVectorTrack(e,t,r,a){var s=this.getTimesForAllAxes(t),t=this.getKeyframeTrackValues(s,t,r);return new THREE.VectorKeyframeTrack(e+"."+a,s,t)}generateRotationTrack(e,t,r,a,s,n){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(THREE.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(THREE.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(THREE.MathUtils.degToRad));var i=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(i,t,r);void 0!==a&&((a=a.map(THREE.MathUtils.degToRad)).push(n),a=(new THREE.Euler).fromArray(a),a=(new THREE.Quaternion).setFromEuler(a)),void 0!==s&&((s=s.map(THREE.MathUtils.degToRad)).push(n),s=(new THREE.Euler).fromArray(s),s=(new THREE.Quaternion).setFromEuler(s).invert());const l=new THREE.Quaternion,c=new THREE.Euler;var u=[];for(let e=0;e<o.length;e+=3)c.set(o[e],o[e+1],o[e+2],n),l.setFromEuler(c),void 0!==a&&l.premultiply(a),void 0!==s&&l.multiply(s),l.toArray(u,e/3*4);return new THREE.QuaternionKeyframeTrack(e+".quaternion",i,u)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph;var r=t.values.map(function(e){return e/100}),a=c.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new THREE.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+a+"]",t.times,r)}getTimesForAllAxes(e){let a=[];if(void 0!==e.x&&(a=a.concat(e.x.times)),void 0!==e.y&&(a=a.concat(e.y.times)),1<(a=(a=void 0!==e.z?a.concat(e.z.times):a).sort(function(e,t){return e-t})).length){let t=1,r=a[0];for(let e=1;e<a.length;e++){var s=a[e];s!==r&&(a[t]=s,r=s,t++)}a=a.slice(0,t)}return a}getKeyframeTrackValues(e,t,r){const a=r,s=[];let n=-1,i=-1,o=-1;return e.forEach(function(e){t.x&&(n=t.x.times.indexOf(e)),t.y&&(i=t.y.times.indexOf(e)),t.z&&(o=t.z.times.indexOf(e)),-1!==n?(e=t.x.values[n],s.push(e),a[0]=e):s.push(a[0]),-1!==i?(e=t.y.values[i],s.push(e),a[1]=e):s.push(a[1]),-1!==o?(e=t.z.values[o],s.push(e),a[2]=e):s.push(a[2])}),s}interpolateRotations(a){for(let r=1;r<a.values.length;r++){var s=a.values[r-1],n=a.values[r]-s,i=Math.abs(n);if(180<=i){var i=i/180,o=n/i;let e=s+o;var n=a.times[r-1],l=(a.times[r]-n)/i;let t=n+l;const c=[],u=[];for(;t<a.times[r];)c.push(t),t+=l,u.push(e),e+=o;a.times=inject(a.times,r,c),a.values=inject(a.values,r,u)}}}}class TextParser{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),--this.currentIndent}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new FBXTree,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const n=this,i=e.split(/[\r\n]+/);return i.forEach(function(e,t){var r,a=e.match(/^[\s\t]*;/),s=e.match(/^[\s\t]*$/);a||s||(a=e.match("^\\t{"+n.currentIndent+"}(\\w+):(.*){",""),s=e.match("^\\t{"+n.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),r=e.match("^\\t{"+(n.currentIndent-1)+"}}"),a?n.parseNodeBegin(e,a):s?n.parseNodeProperty(e,s,i[++t]):r?n.popStack():e.match(/^[^\s\t}]/)&&n.parseNodePropertyContinued(e))}),this.allNodes}parseNodeBegin(e,t){var r=t[1].trim().replace(/^"/,"").replace(/"$/,""),t=t[2].split(",").map(function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")});const a={name:r};t=this.parseNodeAttr(t);const s=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,a):r in s?("PoseNode"===r?s.PoseNode.push(a):void 0!==s[r].id&&(s[r]={},s[r][s[r].id]=s[r]),""!==t.id&&(s[r][t.id]=a)):"number"==typeof t.id?(s[r]={},s[r][t.id]=a):"Properties70"!==r&&(s[r]="PoseNode"===r?[a]:a),"number"==typeof t.id&&(a.id=t.id),""!==t.name&&(a.attrName=t.name),""!==t.type&&(a.attrType=t.type),this.pushStack(a)}parseNodeAttr(e){let t=e[0],r=(""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0])),""),a="";return 1<e.length&&(r=e[1].replace(/^(\w+)::/,""),a=e[2]),{id:t,name:r,type:a}}parseNodeProperty(t,r,a){let s=r[1].replace(/^"/,"").replace(/"$/,"").trim(),n=r[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===s&&","===n&&(n=a.replace(/"/g,"").replace(/,$/,"").trim());const i=this.getCurrentNode();if("Properties70"===i.name)this.parseNodeSpecialProperty(t,s,n);else{if("C"===s){r=n.split(",").slice(1),a=parseInt(r[0]),t=parseInt(r[1]);let e=n.split(",").slice(3);e=e.map(function(e){return e.trim().replace(/^"/,"")}),s="connections",!function append(a,s){for(let e=0,t=a.length,r=s.length;e<r;e++,t++)a[t]=s[e]}(n=[a,t],e),void 0===i[s]&&(i[s]=[])}"Node"===s&&(i.id=n),s in i&&Array.isArray(i[s])?i[s].push(n):"a"!==s?i[s]=n:i.a=n,this.setCurrentProp(i,s),"a"===s&&","!==n.slice(-1)&&(i.a=parseNumberArray(n))}}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=parseNumberArray(t.a))}parseNodeSpecialProperty(e,t,r){var r=r.split('",').map(function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")}),a=r[0],s=r[1],n=r[2],i=r[3];let o=r[4];switch(s){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":o=parseFloat(o);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":o=parseNumberArray(o)}this.getPrevNode()[a]={type:s,type2:n,flag:i,value:o},this.setCurrentProp(this.getPrevNode(),a)}}class BinaryParser{parse(e){const t=new BinaryReader(e);t.skip(23);var r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);const a=new FBXTree;for(;!this.endOfContent(t);){var s=this.parseNode(t,r);null!==s&&a.add(s.name,s)}return a}endOfContent(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(t,e){const r={};var a=7500<=e?t.getUint64():t.getUint32(),s=7500<=e?t.getUint64():t.getUint32(),n=(7500<=e?t.getUint64():t.getUint32(),t.getUint8()),i=t.getString(n);if(0===a)return null;const o=[];for(let e=0;e<s;e++)o.push(this.parseProperty(t));var n=0<o.length?o[0]:"",l=1<o.length?o[1]:"",c=2<o.length?o[2]:"";for(r.singleProperty=1===s&&t.getOffset()===a;a>t.getOffset();){var u=this.parseNode(t,e);null!==u&&this.parseSubNode(i,r,u)}return r.propertyList=o,"number"==typeof n&&(r.id=n),""!==l&&(r.attrName=l),""!==c&&(r.attrType=c),""!==i&&(r.name=i),r}parseSubNode(a,s,n){if(!0===n.singleProperty){var i=n.propertyList[0];Array.isArray(i)?(s[n.name]=n).a=i:s[n.name]=i}else if("Connections"===a&&"C"===n.name){const r=[];n.propertyList.forEach(function(e,t){0!==t&&r.push(e)}),void 0===s.connections&&(s.connections=[]),s.connections.push(r)}else if("Properties70"===n.name){const e=Object.keys(n);e.forEach(function(e){s[e]=n[e]})}else if("Properties70"===a&&"P"===n.name){let e=n.propertyList[0],t=n.propertyList[1];i=n.propertyList[2],a=n.propertyList[3];let r;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===t.indexOf("Lcl ")&&(t=t.replace("Lcl ","Lcl_")),r="Color"===t||"ColorRGB"===t||"Vector"===t||"Vector3D"===t||0===t.indexOf("Lcl_")?[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:n.propertyList[4],s[e]={type:t,type2:i,flag:a,value:r}}else void 0===s[n.name]?"number"==typeof n.id?(s[n.name]={},s[n.name][n.id]=n):s[n.name]=n:"PoseNode"===n.name?(Array.isArray(s[n.name])||(s[n.name]=[s[n.name]]),s[n.name].push(n)):void 0===s[n.name][n.id]&&(s[n.name][n.id]=n)}parseProperty(e){var t=e.getString(1);let r;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return r=e.getUint32(),e.getArrayBuffer(r);case"S":return r=e.getUint32(),e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var a=e.getUint32(),s=e.getUint32(),n=e.getUint32();if(0===s)switch(t){case"b":case"c":return e.getBooleanArray(a);case"d":return e.getFloat64Array(a);case"f":return e.getFloat32Array(a);case"i":return e.getInt32Array(a);case"l":return e.getInt64Array(a)}"undefined"==typeof fflate&&console.error("THREE.FBXLoader: External library fflate.min.js required.");s=fflate.unzlibSync(new Uint8Array(e.getArrayBuffer(n)));const i=new BinaryReader(s.buffer);switch(t){case"b":case"c":return i.getBooleanArray(a);case"d":return i.getFloat64Array(a);case"f":return i.getFloat32Array(a);case"i":return i.getInt32Array(a);case"l":return i.getInt64Array(a)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class BinaryReader{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1==(1&this.getUint8())}getBooleanArray(t){const r=[];for(let e=0;e<t;e++)r.push(this.getBoolean());return r}getUint8(){var e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){var e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){var e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(t){const r=[];for(let e=0;e<t;e++)r.push(this.getInt32());return r}getUint32(){var e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,4294967295===(e=4294967295&~e)&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(t){const r=[];for(let e=0;e<t;e++)r.push(this.getInt64());return r}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){var e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(t){const r=[];for(let e=0;e<t;e++)r.push(this.getFloat32());return r}getFloat64(){var e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(t){const r=[];for(let e=0;e<t;e++)r.push(this.getFloat64());return r}getArrayBuffer(e){var t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(t){let r=[];for(let e=0;e<t;e++)r[e]=this.getUint8();var e=r.indexOf(0);return 0<=e&&(r=r.slice(0,e)),THREE.LoaderUtils.decodeText(new Uint8Array(r))}}class FBXTree{add(e,t){this[e]=t}}function getFbxVersion(e){e=e.match(/FBXVersion: (\d+)/);if(e)return parseInt(e[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function convertFBXTimeToSeconds(e){return e/46186158e3}const E=[];function getData(e,t,r,a){let s;switch(a.mappingType){case"ByPolygonVertex":s=e;break;case"ByPolygon":s=t;break;case"ByVertice":s=r;break;case"AllSame":s=a.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+a.mappingType)}var n=(s="IndexToDirect"===a.referenceType?a.indices[s]:s)*a.dataSize,i=n+a.dataSize;return function slice(r,a,s,n){for(let e=s,t=0;e<n;e++,t++)r[t]=a[e];return r}(E,a.buffer,n,i)}const b=new THREE.Euler,S=new THREE.Vector3;function generateTransform(e){const t=new THREE.Matrix4,r=new THREE.Matrix4,a=new THREE.Matrix4,s=new THREE.Matrix4,n=new THREE.Matrix4,i=new THREE.Matrix4,o=new THREE.Matrix4,l=new THREE.Matrix4,c=new THREE.Matrix4,u=new THREE.Matrix4,d=new THREE.Matrix4,h=new THREE.Matrix4;var p=e.inheritType||0;if(e.translation&&t.setPosition(S.fromArray(e.translation)),e.preRotation){const y=e.preRotation.map(THREE.MathUtils.degToRad);y.push(e.eulerOrder),r.makeRotationFromEuler(b.fromArray(y))}if(e.rotation){const R=e.rotation.map(THREE.MathUtils.degToRad);R.push(e.eulerOrder),a.makeRotationFromEuler(b.fromArray(R))}if(e.postRotation){const x=e.postRotation.map(THREE.MathUtils.degToRad);x.push(e.eulerOrder),s.makeRotationFromEuler(b.fromArray(x)),s.invert()}e.scale&&n.scale(S.fromArray(e.scale)),e.scalingOffset&&o.setPosition(S.fromArray(e.scalingOffset)),e.scalingPivot&&i.setPosition(S.fromArray(e.scalingPivot)),e.rotationOffset&&l.setPosition(S.fromArray(e.rotationOffset)),e.rotationPivot&&c.setPosition(S.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(d.copy(e.parentMatrix),u.copy(e.parentMatrixWorld));e=r.clone().multiply(a).multiply(s);const f=new THREE.Matrix4,m=(f.extractRotation(u),new THREE.Matrix4);m.copyPosition(u);var g=m.clone().invert().multiply(u);const E=f.clone().invert().multiply(g);g=n;const v=new THREE.Matrix4;if(0===p)v.copy(f).multiply(e).multiply(E).multiply(g);else if(1===p)v.copy(f).multiply(E).multiply(e).multiply(g);else{const w=(new THREE.Matrix4).scale((new THREE.Vector3).setFromMatrixScale(d));p=w.clone().invert(),p=E.clone().multiply(p);v.copy(f).multiply(e).multiply(p).multiply(g)}e=c.clone().invert(),p=i.clone().invert();let T=t.clone().multiply(l).multiply(c).multiply(r).multiply(a).multiply(s).multiply(e).multiply(o).multiply(i).multiply(n).multiply(p);g=(new THREE.Matrix4).copyPosition(T),e=u.clone().multiply(g);return h.copyPosition(e),(T=h.clone().multiply(v)).premultiply(u.invert()),T}function getEulerOrder(e){var t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported THREE.Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function parseNumberArray(e){return e.split(",").map(function(e){return parseFloat(e)})}function convertArrayBufferToString(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),THREE.LoaderUtils.decodeText(new Uint8Array(e,t,r))}function inject(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}THREE.FBXLoader=FBXLoader}{const u=new WeakMap;class DRACOLoader extends THREE.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,r,t,a){const s=new THREE.FileLoader(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,e=>{var t={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(e,t).then(r).catch(a)},t,a)}decodeDracoFile(e,t,r,a){a={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:a||this.defaultAttributeTypes,useUniqueIDs:!!r};this.decodeGeometry(e,a).then(t)}decodeGeometry(r,a){for(const l in a.attributeTypes){var e=a.attributeTypes[l];void 0!==e.BYTES_PER_ELEMENT&&(a.attributeTypes[l]=e.name)}var t=JSON.stringify(a);if(u.has(r)){var s=u.get(r);if(s.key===t)return s.promise;if(0===r.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let n;const i=this.workerNextTaskID++;s=r.byteLength;const o=this._getWorker(i,s).then(e=>(n=e,new Promise((e,t)=>{n._callbacks[i]={resolve:e,reject:t},n.postMessage({type:"decode",id:i,taskConfig:a,buffer:r},[r])}))).then(e=>this._createGeometry(e.geometry));return o.catch(()=>!0).then(()=>{n&&i&&this._releaseTask(n,i)}),u.set(r,{key:t,promise:o}),o}_createGeometry(t){const r=new THREE.BufferGeometry;t.index&&r.setIndex(new THREE.BufferAttribute(t.index.array,1));for(let e=0;e<t.attributes.length;e++){var a=t.attributes[e],s=a.name,n=a.array,a=a.itemSize;r.setAttribute(s,new THREE.BufferAttribute(n,a))}return r}_loadLibrary(r,e){const a=new THREE.FileLoader(this.manager);return a.setPath(this.decoderPath),a.setResponseType(e),a.setWithCredentials(this.withCredentials),new Promise((e,t)=>{a.load(r,e,void 0,t)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const a="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,e=[];return a?e.push(this._loadLibrary("draco_decoder.js","text")):(e.push(this._loadLibrary("draco_wasm_wrapper.js","text")),e.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(e).then(e=>{const t=e[0],r=(a||(this.decoderConfig.wasmBinary=e[1]),function DRACOWorker(){let r,t;function decodeGeometry(r,a,e,s){var n=s.attributeIDs,i=s.attributeTypes;let o,t;var l=a.GetEncodedGeometryType(e);if(l===r.TRIANGULAR_MESH)o=new r.Mesh,t=a.DecodeBufferToMesh(e,o);else{if(l!==r.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new r.PointCloud,t=a.DecodeBufferToPointCloud(e,o)}if(!t.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+t.error_msg());const c={index:null,attributes:[]};for(const d in n){var u=self[i[d]];let e,t;if(s.useUniqueIDs)t=n[d],e=a.GetAttributeByUniqueId(o,t);else{if(-1===(t=a.GetAttributeId(o,r[n[d]])))continue;e=a.GetAttribute(o,t)}c.attributes.push(function decodeAttribute(e,t,r,a,s,n){var i=n.num_components(),o=r.num_points(),o=o*i,l=o*s.BYTES_PER_ELEMENT,c=function getDracoDataType(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),u=e._malloc(l),t=(t.GetAttributeDataArrayForAllPoints(r,n,c,l,u),new s(e.HEAPF32.buffer,u,o).slice());return e._free(u),{name:a,array:t,itemSize:i}}(r,a,o,d,u,e))}return l===r.TRIANGULAR_MESH&&(c.index=function decodeIndex(e,t,r){var a=r.num_faces(),a=3*a,s=4*a,n=e._malloc(s),t=(t.GetTrianglesUInt32Array(r,s,n),new Uint32Array(e.HEAPF32.buffer,n,a).slice());return e._free(n),{array:t,itemSize:1}}(r,a,o)),r.destroy(o),c}onmessage=function(e){const n=e.data;switch(n.type){case"init":r=n.decoderConfig,t=new Promise(function(t){r.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(r)});break;case"decode":const i=n.buffer,o=n.taskConfig;t.then(e=>{const t=e.draco;e=new t.Decoder;const r=new t.DecoderBuffer;r.Init(new Int8Array(i),i.byteLength);try{const a=decodeGeometry(t,e,r,o),s=a.attributes.map(e=>e.array.buffer);a.index&&s.push(a.index.array.buffer),self.postMessage({type:"decode",id:n.id,geometry:a},s)}catch(e){console.error(e),self.postMessage({type:"error",id:n.id,error:e.message})}finally{t.destroy(r),t.destroy(e)}})}}}.toString());e=["/* draco decoder */",t,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([e]))}),this.decoderPending}_getWorker(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const r=new Worker(this.workerSourceURL);r._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(e){var t=e.data;switch(t.type){case"decode":r._callbacks[t.id].resolve(t);break;case"error":r._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(r)}else this.workerPool.sort(function(e,t){return e._taskLoad>t._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=t,r._taskLoad+=t,r})}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}THREE.DRACOLoader=DRACOLoader}{class SVGLoader extends THREE.Loader{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(t,r,e,a){const s=this,n=new THREE.FileLoader(s.manager);n.setPath(s.path),n.setRequestHeader(s.requestHeader),n.setWithCredentials(s.withCredentials),n.load(t,function(e){try{r(s.parse(e))}catch(e){a?a(e):console.error(e),s.manager.itemError(t)}},e,a)}parse(e){const t=this;function parseArcCommand(a,s,n,i,o,l,c,u){if(0==s||0==n)a.lineTo(u.x,u.y);else{i=i*Math.PI/180,s=Math.abs(s),n=Math.abs(n);var d=(c.x-u.x)/2,h=(c.y-u.y)/2,p=Math.cos(i)*d+Math.sin(i)*h,d=-Math.sin(i)*d+Math.cos(i)*h;let e=s*s,t=n*n;var h=p*p,f=d*d,m=h/e+f/t,m=(1<m&&(s*=m=Math.sqrt(m),n*=m,e=s*s,t=n*n),e*f+t*h),f=(e*t-m)/m;let r=Math.sqrt(Math.max(0,f));h=(r=o===l?-r:r)*s*d/n,m=-r*n*p/s,f=Math.cos(i)*h-Math.sin(i)*m+(c.x+u.x)/2,o=Math.sin(i)*h+Math.cos(i)*m+(c.y+u.y)/2,c=svgAngle(1,0,(p-h)/s,(d-m)/n),u=svgAngle((p-h)/s,(d-m)/n,(-p-h)/s,(-d-m)/n)%(2*Math.PI);a.currentPath.absellipse(f,o,s,n,c,c+u,0===l,i)}}function svgAngle(e,t,r,a){var s=e*r+t*a,n=Math.sqrt(e*e+t*t)*Math.sqrt(r*r+a*a);let i=Math.acos(Math.max(-1,Math.min(1,s/n)));return i=e*a-t*r<0?-i:i}function parseStyle(a,s){s=Object.assign({},s);let n={};if(a.hasAttribute("class")){var t=a.getAttribute("class").split(/\s/).filter(Boolean).map(e=>e.trim());for(let e=0;e<t.length;e++)n=Object.assign(n,u["."+t[e]])}function addStyle(e,t,r){void 0===r&&(r=function copy(e){return e.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),e}),a.hasAttribute(e)&&(s[t]=r(a.getAttribute(e))),n[e]&&(s[t]=r(n[e])),a.style&&""!==a.style[e]&&(s[t]=r(a.style[e]))}function clamp(e){return Math.max(0,Math.min(1,parseFloatWithUnits(e)))}function positive(e){return Math.max(0,parseFloatWithUnits(e))}return a.hasAttribute("id")&&(n=Object.assign(n,u["#"+a.getAttribute("id")])),addStyle("fill","fill"),addStyle("fill-opacity","fillOpacity",clamp),addStyle("fill-rule","fillRule"),addStyle("opacity","opacity",clamp),addStyle("stroke","stroke"),addStyle("stroke-opacity","strokeOpacity",clamp),addStyle("stroke-width","strokeWidth",positive),addStyle("stroke-linejoin","strokeLineJoin"),addStyle("stroke-linecap","strokeLineCap"),addStyle("stroke-miterlimit","strokeMiterLimit",positive),addStyle("visibility","visibility"),s}function getReflection(e,t){return e-(t-e)}function parseFloats(t,r,a){if("string"!=typeof t)throw new TypeError("Invalid input: "+typeof t);const s={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};var n;let i=0,o=!0,l="",c="";const u=[];function throwSyntaxError(e,t,r){const a=new SyntaxError('Unexpected character "'+e+'" at index '+t+".");throw a.partial=r,a}function newNumber(){""!==l&&(""===c?u.push(Number(l)):u.push(Number(l)*Math.pow(10,Number(c)))),l="",c=""}var d=t.length;for(let e=0;e<d;e++)if(n=t[e],Array.isArray(r)&&r.includes(u.length%a)&&s.FLAGS.test(n))i=1,l=n,newNumber();else{if(0===i){if(s.WHITESPACE.test(n))continue;if(s.DIGIT.test(n)||s.SIGN.test(n)){i=1,l=n;continue}if(s.POINT.test(n)){i=2,l=n;continue}s.COMMA.test(n)&&(o&&throwSyntaxError(n,e,u),o=!0)}if(1===i){if(s.DIGIT.test(n)){l+=n;continue}if(s.POINT.test(n)){l+=n,i=2;continue}if(s.EXP.test(n)){i=3;continue}s.SIGN.test(n)&&1===l.length&&s.SIGN.test(l[0])&&throwSyntaxError(n,e,u)}if(2===i){if(s.DIGIT.test(n)){l+=n;continue}if(s.EXP.test(n)){i=3;continue}s.POINT.test(n)&&"."===l[l.length-1]&&throwSyntaxError(n,e,u)}if(3===i){if(s.DIGIT.test(n)){c+=n;continue}if(s.SIGN.test(n)){if(""===c){c+=n;continue}1===c.length&&s.SIGN.test(c)&&throwSyntaxError(n,e,u)}}s.WHITESPACE.test(n)?(newNumber(),i=0,o=!1):s.COMMA.test(n)?(newNumber(),i=0,o=!0):s.SIGN.test(n)?(newNumber(),i=1,l=n):s.POINT.test(n)?(newNumber(),i=2,l=n):throwSyntaxError(n,e,u)}return newNumber(),u}const n=["mm","cm","in","pt","pc","px"],i={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function parseFloatWithUnits(r){let a="px";if("string"==typeof r||r instanceof String)for(let e=0,t=n.length;e<t;e++){var s=n[e];if(r.endsWith(s)){a=s,r=r.substring(0,r.length-s.length);break}}let e=void 0;return"px"===a&&"px"!==t.defaultUnit?e=i.in[t.defaultUnit]/t.defaultDPI:(e=i[a][t.defaultUnit])<0&&(e=i[a].in*t.defaultDPI),e*parseFloat(r)}const c=[],u={},d=[],h=new THREE.Matrix3,p=new THREE.Matrix3,f=new THREE.Matrix3,m=new THREE.Matrix3,g=new THREE.Vector2,E=new THREE.Vector3,v=new THREE.Matrix3;e=(new DOMParser).parseFromString(e,"image/svg+xml"),function parseNode(r,a){if(1===r.nodeType){var s=function getNodeTransform(e){if(!(e.hasAttribute("transform")||"use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))))return null;const t=function parseNodeTransform(e){const t=new THREE.Matrix3,r=h;var a,s;if("use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))&&(a=parseFloatWithUnits(e.getAttribute("x")),s=parseFloatWithUnits(e.getAttribute("y")),t.translate(a,s)),e.hasAttribute("transform")){const u=e.getAttribute("transform").split(")");for(let e=u.length-1;0<=e;e--){const d=u[e].trim();if(""!==d){var n=d.indexOf("("),i=d.length;if(0<n&&n<i){var i=d.slice(0,n),o=parseFloats(d.slice(n+1));switch(r.identity(),i){case"translate":if(1<=o.length){var l=o[0];let e=l;2<=o.length&&(e=o[1]),r.translate(l,e)}break;case"rotate":if(1<=o.length){let e=l=0,t=0;l=-o[0]*Math.PI/180,3<=o.length&&(e=o[1],t=o[2]),p.identity().translate(-e,-t),f.identity().rotate(l),m.multiplyMatrices(f,p),p.identity().translate(e,t),r.multiplyMatrices(p,m)}break;case"scale":if(1<=o.length){var c=o[0];let e=c;2<=o.length&&(e=o[1]),r.scale(c,e)}break;case"skewX":1===o.length&&r.set(1,Math.tan(o[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===o.length&&r.set(1,0,0,Math.tan(o[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===o.length&&r.set(o[0],o[2],o[4],o[1],o[3],o[5],0,0,1)}}t.premultiply(r)}}}return t}(e);return 0<d.length&&t.premultiply(d[d.length-1]),v.copy(t),d.push(t),t}(r);let t=!1,e=null;switch(r.nodeName){case"svg":break;case"style":!function parseCSSStylesheet(t){if(t.sheet&&t.sheet.cssRules&&t.sheet.cssRules.length)for(let e=0;e<t.sheet.cssRules.length;e++){const s=t.sheet.cssRules[e];if(1===s.type){var r=s.selectorText.split(/,/gm).filter(Boolean).map(e=>e.trim());for(let e=0;e<r.length;e++){var a=Object.fromEntries(Object.entries(s.style).filter(([,e])=>""!==e));u[r[e]]=Object.assign(u[r[e]]||{},a)}}}}(r);break;case"g":a=parseStyle(r,a);break;case"path":a=parseStyle(r,a),r.hasAttribute("d")&&(e=function parsePathNode(e){const a=new THREE.ShapePath,s=new THREE.Vector2,n=new THREE.Vector2,i=new THREE.Vector2;let o=!0,l=!1;const t=e.getAttribute("d"),c=t.match(/[a-df-z][^a-df-z]*/gi);for(let e=0,t=c.length;e<t;e++){const v=c[e];var u,d,h=v.charAt(0),p=v.slice(1).trim();!0===o&&(l=!0,o=!1);let r;switch(h){case"M":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2)s.x=r[e+0],s.y=r[e+1],n.x=s.x,n.y=s.y,0===e?a.moveTo(s.x,s.y):a.lineTo(s.x,s.y),0===e&&i.copy(s);break;case"H":r=parseFloats(p);for(let e=0,t=r.length;e<t;e++)s.x=r[e],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"V":r=parseFloats(p);for(let e=0,t=r.length;e<t;e++)s.y=r[e],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"L":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2)s.x=r[e+0],s.y=r[e+1],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"C":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=6)a.bezierCurveTo(r[e+0],r[e+1],r[e+2],r[e+3],r[e+4],r[e+5]),n.x=r[e+2],n.y=r[e+3],s.x=r[e+4],s.y=r[e+5],0===e&&!0===l&&i.copy(s);break;case"S":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=4)a.bezierCurveTo(getReflection(s.x,n.x),getReflection(s.y,n.y),r[e+0],r[e+1],r[e+2],r[e+3]),n.x=r[e+0],n.y=r[e+1],s.x=r[e+2],s.y=r[e+3],0===e&&!0===l&&i.copy(s);break;case"Q":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=4)a.quadraticCurveTo(r[e+0],r[e+1],r[e+2],r[e+3]),n.x=r[e+0],n.y=r[e+1],s.x=r[e+2],s.y=r[e+3],0===e&&!0===l&&i.copy(s);break;case"T":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2){var f=getReflection(s.x,n.x),m=getReflection(s.y,n.y);a.quadraticCurveTo(f,m,r[e+0],r[e+1]),n.x=f,n.y=m,s.x=r[e+0],s.y=r[e+1],0===e&&!0===l&&i.copy(s)}break;case"A":r=parseFloats(p,[3,4],7);for(let e=0,t=r.length;e<t;e+=7)r[e+5]==s.x&&r[e+6]==s.y||(u=s.clone(),s.x=r[e+5],s.y=r[e+6],n.x=s.x,n.y=s.y,parseArcCommand(a,r[e],r[e+1],r[e+2],r[e+3],r[e+4],u,s),0===e&&!0===l&&i.copy(s));break;case"m":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2)s.x+=r[e+0],s.y+=r[e+1],n.x=s.x,n.y=s.y,0===e?a.moveTo(s.x,s.y):a.lineTo(s.x,s.y),0===e&&i.copy(s);break;case"h":r=parseFloats(p);for(let e=0,t=r.length;e<t;e++)s.x+=r[e],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"v":r=parseFloats(p);for(let e=0,t=r.length;e<t;e++)s.y+=r[e],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"l":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2)s.x+=r[e+0],s.y+=r[e+1],n.x=s.x,n.y=s.y,a.lineTo(s.x,s.y),0===e&&!0===l&&i.copy(s);break;case"c":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=6)a.bezierCurveTo(s.x+r[e+0],s.y+r[e+1],s.x+r[e+2],s.y+r[e+3],s.x+r[e+4],s.y+r[e+5]),n.x=s.x+r[e+2],n.y=s.y+r[e+3],s.x+=r[e+4],s.y+=r[e+5],0===e&&!0===l&&i.copy(s);break;case"s":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=4)a.bezierCurveTo(getReflection(s.x,n.x),getReflection(s.y,n.y),s.x+r[e+0],s.y+r[e+1],s.x+r[e+2],s.y+r[e+3]),n.x=s.x+r[e+0],n.y=s.y+r[e+1],s.x+=r[e+2],s.y+=r[e+3],0===e&&!0===l&&i.copy(s);break;case"q":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=4)a.quadraticCurveTo(s.x+r[e+0],s.y+r[e+1],s.x+r[e+2],s.y+r[e+3]),n.x=s.x+r[e+0],n.y=s.y+r[e+1],s.x+=r[e+2],s.y+=r[e+3],0===e&&!0===l&&i.copy(s);break;case"t":r=parseFloats(p);for(let e=0,t=r.length;e<t;e+=2){var g=getReflection(s.x,n.x),E=getReflection(s.y,n.y);a.quadraticCurveTo(g,E,s.x+r[e+0],s.y+r[e+1]),n.x=g,n.y=E,s.x=s.x+r[e+0],s.y=s.y+r[e+1],0===e&&!0===l&&i.copy(s)}break;case"a":r=parseFloats(p,[3,4],7);for(let e=0,t=r.length;e<t;e+=7)0==r[e+5]&&0==r[e+6]||(d=s.clone(),s.x+=r[e+5],s.y+=r[e+6],n.x=s.x,n.y=s.y,parseArcCommand(a,r[e],r[e+1],r[e+2],r[e+3],r[e+4],d,s),0===e&&!0===l&&i.copy(s));break;case"Z":case"z":a.currentPath.autoClose=!0,0<a.currentPath.curves.length&&(s.copy(i),a.currentPath.currentPoint.copy(s),o=!0);break;default:console.warn(v)}l=!1}return a}(r));break;case"rect":a=parseStyle(r,a),e=function parseRectNode(e){const t=parseFloatWithUnits(e.getAttribute("x")||0),r=parseFloatWithUnits(e.getAttribute("y")||0),a=parseFloatWithUnits(e.getAttribute("rx")||e.getAttribute("ry")||0),s=parseFloatWithUnits(e.getAttribute("ry")||e.getAttribute("rx")||0),n=parseFloatWithUnits(e.getAttribute("width")),i=parseFloatWithUnits(e.getAttribute("height")),o=.448084975506,l=new THREE.ShapePath;return l.moveTo(t+a,r),l.lineTo(t+n-a,r),0===a&&0===s||l.bezierCurveTo(t+n-a*o,r,t+n,r+s*o,t+n,r+s),l.lineTo(t+n,r+i-s),0===a&&0===s||l.bezierCurveTo(t+n,r+i-s*o,t+n-a*o,r+i,t+n-a,r+i),l.lineTo(t+a,r+i),0===a&&0===s||l.bezierCurveTo(t+a*o,r+i,t,r+i-s*o,t,r+i-s),l.lineTo(t,r+s),0===a&&0===s||l.bezierCurveTo(t,r+s*o,t+a*o,r,t+a,r),l}(r);break;case"polygon":a=parseStyle(r,a),e=function parsePolygonNode(e){const a=new THREE.ShapePath;let s=0;return e.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,function iterator(e,t,r){t=parseFloatWithUnits(t),r=parseFloatWithUnits(r),0===s?a.moveTo(t,r):a.lineTo(t,r),s++}),a.currentPath.autoClose=!0,a}(r);break;case"polyline":a=parseStyle(r,a),e=function parsePolylineNode(e){const a=new THREE.ShapePath;let s=0;return e.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,function iterator(e,t,r){t=parseFloatWithUnits(t),r=parseFloatWithUnits(r),0===s?a.moveTo(t,r):a.lineTo(t,r),s++}),a.currentPath.autoClose=!1,a}(r);break;case"circle":a=parseStyle(r,a),e=function parseCircleNode(e){const t=parseFloatWithUnits(e.getAttribute("cx")||0),r=parseFloatWithUnits(e.getAttribute("cy")||0),a=parseFloatWithUnits(e.getAttribute("r")||0),s=new THREE.Path,n=(s.absarc(t,r,a,0,2*Math.PI),new THREE.ShapePath);return n.subPaths.push(s),n}(r);break;case"ellipse":a=parseStyle(r,a),e=function parseEllipseNode(e){const t=parseFloatWithUnits(e.getAttribute("cx")||0),r=parseFloatWithUnits(e.getAttribute("cy")||0),a=parseFloatWithUnits(e.getAttribute("rx")||0),s=parseFloatWithUnits(e.getAttribute("ry")||0),n=new THREE.Path,i=(n.absellipse(t,r,a,s,0,2*Math.PI),new THREE.ShapePath);return i.subPaths.push(n),i}(r);break;case"line":a=parseStyle(r,a),e=function parseLineNode(e){const t=parseFloatWithUnits(e.getAttribute("x1")||0),r=parseFloatWithUnits(e.getAttribute("y1")||0),a=parseFloatWithUnits(e.getAttribute("x2")||0),s=parseFloatWithUnits(e.getAttribute("y2")||0),n=new THREE.ShapePath;return n.moveTo(t,r),n.lineTo(a,s),n.currentPath.autoClose=!1,n}(r);break;case"defs":t=!0;break;case"use":a=parseStyle(r,a);const l=r.getAttributeNS("http://www.w3.org/1999/xlink","href")||"";var n=l.substring(1),i=r.viewportElement.getElementById(n);i?parseNode(i,a):console.warn("SVGLoader: 'use node' references non-existent node id: "+n)}e&&(void 0!==a.fill&&"none"!==a.fill&&e.color.setStyle(a.fill),function transformPath(e,r){function transfVec2(e){E.set(e.x,e.y,1).applyMatrix3(r),e.set(E.x,E.y)}var a=function isTransformRotated(e){return 0!==e.elements[1]||0!==e.elements[3]}(r),s=e.subPaths;for(let e=0,t=s.length;e<t;e++){var n=s[e].curves;for(let e=0;e<n.length;e++){const i=n[e];i.isLineCurve?(transfVec2(i.v1),transfVec2(i.v2)):i.isCubicBezierCurve?(transfVec2(i.v0),transfVec2(i.v1),transfVec2(i.v2),transfVec2(i.v3)):i.isQuadraticBezierCurve?(transfVec2(i.v0),transfVec2(i.v1),transfVec2(i.v2)):i.isEllipseCurve&&(a&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),g.set(i.aX,i.aY),transfVec2(g),i.aX=g.x,i.aY=g.y,i.xRadius*=function getTransformScaleX(e){return e=e.elements,Math.sqrt(e[0]*e[0]+e[1]*e[1])}(r),i.yRadius*=function getTransformScaleY(e){return e=e.elements,Math.sqrt(e[3]*e[3]+e[4]*e[4])}(r))}}}(e,v),c.push(e),e.userData={node:r,style:a});var o=r.childNodes;for(let e=0;e<o.length;e++){const r=o[e];t&&"style"!==r.nodeName&&"defs"!==r.nodeName||parseNode(r,a)}s&&(d.pop(),0<d.length?v.copy(d[d.length-1]):v.identity())}}(e.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),e={paths:c,xml:e.documentElement};return e}static createShapes(t){const e=999999999,m={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},g={loc:m.ORIGIN,t:0};function classifyPoint(e,t,r){var a=r.x-t.x,s=r.y-t.y,n=e.x-t.x,i=e.y-t.y,o=a*i-n*s;if(e.x===t.x&&e.y===t.y)return g.loc=m.ORIGIN,void(g.t=0);if(e.x===r.x&&e.y===r.y)return g.loc=m.DESTINATION,void(g.t=1);if(o<-Number.EPSILON)g.loc=m.LEFT;else if(o>Number.EPSILON)g.loc=m.RIGHT;else if(a*n<0||s*i<0)g.loc=m.BEHIND;else if(Math.sqrt(a*a+s*s)<Math.sqrt(n*n+i*i))g.loc=m.BEYOND;else{let e;e=0!=a?n/a:i/s,g.loc=m.BETWEEN,g.t=e}}function getIntersections(t,r){const a=[],s=[];for(let e=1;e<t.length;e++){var n=t[e-1],i=t[e];for(let e=1;e<r.length;e++){const o=function findEdgeIntersection(t,r,a,s){var n,i,o=t.x,l=r.x,e=a.x,c=s.x,u=t.y,d=r.y,h=a.y,p=s.y,f=(c-e)*(u-h)-(p-h)*(o-e),c=f/(p=(p-h)*(l-o)-(c-e)*(d-u)),h=((l-o)*(u-h)-(d-u)*(o-e))/p;if(0==p&&0!=f||c<=0||1<=c||h<0||1<h)return null;if(0==f&&0==p){for(let e=0;e<2;e++){if(classifyPoint(0===e?a:s,t,r),g.loc==m.ORIGIN)return{x:(n=0===e?a:s).x,y:n.y,t:g.t};if(g.loc==m.BETWEEN)return{x:+(o+g.t*(l-o)).toPrecision(10),y:+(u+g.t*(d-u)).toPrecision(10),t:g.t}}return null}for(let e=0;e<2;e++)if(classifyPoint(0===e?a:s,t,r),g.loc==m.ORIGIN)return{x:(i=0===e?a:s).x,y:i.y,t:g.t};return{x:+(o+c*(l-o)).toPrecision(10),y:+(u+c*(d-u)).toPrecision(10),t:c}}(n,i,r[e-1],r[e]);null!==o&&void 0===a.find(e=>e.t<=o.t+Number.EPSILON&&e.t>=o.t-Number.EPSILON)&&(a.push(o),s.push(new THREE.Vector2(o.x,o.y)))}}return s}function isHoleTo(s,n,e,t,r){null!=r&&""!==r||(r="nonzero");var a=new THREE.Vector2,e=(s.boundingBox.getCenter(a),[new THREE.Vector2(e,a.y),new THREE.Vector2(t,a.y)]);const i=function getScanlineIntersections(r,e,t){const a=new THREE.Vector2,s=(e.getCenter(a),[]);return t.forEach(t=>{if(t.boundingBox.containsPoint(a)){const e=getIntersections(r,t.points);e.forEach(e=>{s.push({identifier:t.identifier,isCW:t.isCW,point:e})})}}),s.sort((e,t)=>e.point.x-t.point.x),s}(e,s.boundingBox,n),o=(i.sort((e,t)=>e.point.x-t.point.x),[]),l=[];i.forEach(e=>{(e.identifier===s.identifier?o:l).push(e)});var c=o[0].point.x;const u=[];let d=0;for(;d<l.length&&l[d].point.x<c;)0<u.length&&u[u.length-1]===l[d].identifier?u.pop():u.push(l[d].identifier),d++;if(u.push(s.identifier),"evenodd"===r)return t=u.length%2==0,a=u[u.length-2],{identifier:s.identifier,isHole:t,for:a};if("nonzero"===r){let t=!0,r=null,a=null;for(let e=0;e<u.length;e++){var h=u[e];t?(a=n[h].isCW,t=!1,r=h):a!==n[h].isCW&&(a=n[h].isCW,t=!0)}return{identifier:s.identifier,isHole:t,for:r}}console.warn('fill-rule: "'+r+'" is currently not implemented.')}let o=0,l=e,c=-e,a=t.subPaths.map(t=>{var r=t.getPoints();let a=-e,s=e,n=-e,i=e;for(let e=0;e<r.length;e++){const t=r[e];t.y>a&&(a=t.y),t.y<s&&(s=t.y),t.x>n&&(n=t.x),t.x<i&&(i=t.x)}return c<=n&&(c=n+1),l>=i&&(l=i-1),{curves:t.curves,points:r,isCW:THREE.ShapeUtils.isClockWise(r),identifier:o++,boundingBox:new THREE.Box2(new THREE.Vector2(i,s),new THREE.Vector2(n,a))}});const s=(a=a.filter(e=>1<e.points.length)).map(e=>isHoleTo(e,a,l,c,t.userData.style.fillRule)),n=[];return a.forEach(t=>{if(!s[t.identifier].isHole){const r=new THREE.Shape,e=(r.curves=t.curves,s.filter(e=>e.isHole&&e.for===t.identifier));e.forEach(e=>{e=a[e.identifier];const t=new THREE.Path;t.curves=e.curves,r.holes.push(t)}),n.push(r)}}),n}static getStrokeStyle(e,t,r,a,s){return{strokeColor:t=void 0!==t?t:"#000",strokeWidth:e=void 0!==e?e:1,strokeLineJoin:r=void 0!==r?r:"miter",strokeLineCap:a=void 0!==a?a:"butt",strokeMiterLimit:s=void 0!==s?s:4}}static pointsToStroke(e,t,r,a){var s=[],n=[],i=[];if(0===SVGLoader.pointsToStrokeWithBuffers(e,t,r,a,s,n,i))return null;const o=new THREE.BufferGeometry;return o.setAttribute("position",new THREE.Float32BufferAttribute(s,3)),o.setAttribute("normal",new THREE.Float32BufferAttribute(n,3)),o.setAttribute("uv",new THREE.Float32BufferAttribute(i,2)),o}static pointsToStrokeWithBuffers(t,o,l,n,c,a,D,e){const u=new THREE.Vector2,d=new THREE.Vector2,h=new THREE.Vector2,p=new THREE.Vector2,r=new THREE.Vector2,s=new THREE.Vector2,i=new THREE.Vector2,f=new THREE.Vector2,m=new THREE.Vector2,U=new THREE.Vector2,N=new THREE.Vector2,g=new THREE.Vector2,E=new THREE.Vector2,v=new THREE.Vector2,T=new THREE.Vector2,y=new THREE.Vector2,R=new THREE.Vector2;l=void 0!==l?l:12,n=void 0!==n?n:.001,e=void 0!==e?e:0;var x=(t=function removeDuplicatedPoints(r){let a=!1;for(let e=1,t=r.length-1;e<t;e++)if(r[e].distanceTo(r[e+1])<n){a=!0;break}if(!a)return r;const s=[];s.push(r[0]);for(let e=1,t=r.length-1;e<t;e++)r[e].distanceTo(r[e+1])>=n&&s.push(r[e]);return s.push(r[r.length-1]),s}(t)).length;if(x<2)return 0;var O=t[0].equals(t[x-1]);let w,k=t[0],b;var S=o.strokeWidth/2,B=1/(x-1);let M=0,A,L,H,I,V=!1,G=0,F=3*e,j=2*e;getNormal(t[0],t[1],u).multiplyScalar(S),f.copy(t[0]).sub(u),m.copy(t[0]).add(u),U.copy(f),N.copy(m);for(let e=1;e<x;e++){w=t[e],b=e===x-1?O?t[1]:void 0:t[e+1];const P=u;if(getNormal(k,w,P),h.copy(P).multiplyScalar(S),g.copy(w).sub(h),E.copy(w).add(h),A=M+B,L=!1,void 0!==b){getNormal(w,b,d),h.copy(d).multiplyScalar(S),v.copy(w).sub(h),T.copy(w).add(h),H=!0,h.subVectors(b,k),P.dot(h)<0&&(H=!1),1===e&&(V=H),h.subVectors(b,w),h.normalize();var C=Math.abs(P.dot(h));if(0!==C){var C=S/C,z=(h.multiplyScalar(-C),p.subVectors(w,k),r.copy(p).setLength(C).add(h),y.copy(r).negate(),r.length()),C=p.length(),W=(p.divideScalar(C),s.subVectors(b,w),s.length());switch(s.divideScalar(W),p.dot(y)<C&&s.dot(y)<W&&(L=!0),R.copy(r).add(w),y.add(w),I=!1,L?H?(T.copy(y),E.copy(y)):(v.copy(y),g.copy(y)):makeSegmentTriangles(),o.strokeLineJoin){case"bevel":makeSegmentWithBevelJoin(H,L,A);break;case"round":createSegmentTrianglesWithMiddleSection(H,L),H?makeCircularSector(w,g,v,A,0):makeCircularSector(w,T,E,A,1);break;default:var _=S*o.strokeMiterLimit/z;if(_<1){if("miter-clip"!==o.strokeLineJoin){makeSegmentWithBevelJoin(H,L,A);break}createSegmentTrianglesWithMiddleSection(H,L),H?(s.subVectors(R,g).multiplyScalar(_).add(g),i.subVectors(R,v).multiplyScalar(_).add(v),addVertex(g,A,0),addVertex(s,A,0),addVertex(w,A,.5),addVertex(w,A,.5),addVertex(s,A,0),addVertex(i,A,0),addVertex(w,A,.5),addVertex(i,A,0),addVertex(v,A,0)):(s.subVectors(R,E).multiplyScalar(_).add(E),i.subVectors(R,T).multiplyScalar(_).add(T),addVertex(E,A,1),addVertex(s,A,1),addVertex(w,A,.5),addVertex(w,A,.5),addVertex(s,A,1),addVertex(i,A,1),addVertex(w,A,.5),addVertex(i,A,1),addVertex(T,A,1))}else L?(H?(addVertex(m,M,1),addVertex(f,M,0),addVertex(R,A,0),addVertex(m,M,1),addVertex(R,A,0),addVertex(y,A,1)):(addVertex(m,M,1),addVertex(f,M,0),addVertex(R,A,1),addVertex(f,M,0),addVertex(y,A,0),addVertex(R,A,1)),(H?v:T).copy(R)):H?(addVertex(g,A,0),addVertex(R,A,0),addVertex(w,A,.5),addVertex(w,A,.5),addVertex(R,A,0),addVertex(v,A,0)):(addVertex(E,A,1),addVertex(R,A,1),addVertex(w,A,.5),addVertex(w,A,.5),addVertex(R,A,1),addVertex(T,A,1)),I=!0}}else makeSegmentTriangles()}else makeSegmentTriangles();O||e!==x-1||addCapGeometry(t[0],U,N,H,!0,M),M=A,k=w,f.copy(v),m.copy(T)}if(O){if(L&&c){let e=R,t=y;V!==H&&(e=y,t=R),H?(I||V)&&(t.toArray(c,0),t.toArray(c,9),I&&e.toArray(c,3)):!I&&V||(t.toArray(c,3),t.toArray(c,9),I&&e.toArray(c,0))}}else addCapGeometry(w,g,E,H,!1,A);return G;function getNormal(e,t,r){return r.subVectors(t,e),r.set(-r.y,r.x).normalize()}function addVertex(e,t,r){c&&(c[F]=e.x,c[F+1]=e.y,c[F+2]=0,a&&(a[F]=0,a[F+1]=0,a[F+2]=1),F+=3,D&&(D[j]=t,D[j+1]=r,j+=2)),G+=3}function makeCircularSector(r,e,t,a,s){u.copy(e).sub(r).normalize(),d.copy(t).sub(r).normalize();let n=Math.PI;var i=u.dot(d);Math.abs(i)<1&&(n=Math.abs(Math.acos(i))),n/=l,h.copy(e);for(let e=0,t=l-1;e<t;e++)p.copy(h).rotateAround(r,n),addVertex(h,a,s),addVertex(p,a,s),addVertex(r,a,.5),h.copy(p);addVertex(p,a,s),addVertex(t,a,s),addVertex(r,a,.5)}function makeSegmentTriangles(){addVertex(m,M,1),addVertex(f,M,0),addVertex(g,A,0),addVertex(m,M,1),addVertex(g,A,1),addVertex(E,A,0)}function makeSegmentWithBevelJoin(e,t,r){t?(e?(addVertex(m,M,1),addVertex(f,M,0),addVertex(g,A,0),addVertex(m,M,1),addVertex(g,A,0),addVertex(y,A,1),addVertex(g,r,0),addVertex(v,r,0)):(addVertex(m,M,1),addVertex(f,M,0),addVertex(E,A,1),addVertex(f,M,0),addVertex(y,A,0),addVertex(E,A,1),addVertex(E,r,1),addVertex(T,r,0)),addVertex(y,r,.5)):(e?(addVertex(g,r,0),addVertex(v,r,0)):(addVertex(E,r,1),addVertex(T,r,0)),addVertex(w,r,.5))}function createSegmentTrianglesWithMiddleSection(e,t){t&&(e?(addVertex(m,M,1),addVertex(f,M,0),addVertex(g,A,0),addVertex(m,M,1),addVertex(g,A,0),addVertex(y,A,1),addVertex(g,M,0),addVertex(w,A,.5),addVertex(y,A,1),addVertex(w,A,.5),addVertex(v,M,0),addVertex(y,A,1)):(addVertex(m,M,1),addVertex(f,M,0),addVertex(E,A,1),addVertex(f,M,0),addVertex(y,A,0),addVertex(E,A,1),addVertex(E,M,1),addVertex(y,A,0),addVertex(w,A,.5),addVertex(w,A,.5),addVertex(y,A,0),addVertex(T,M,1)))}function addCapGeometry(e,t,r,a,s,n){switch(o.strokeLineCap){case"round":s?makeCircularSector(e,r,t,n,.5):makeCircularSector(e,t,r,n,.5);break;case"square":var i;s?(u.subVectors(t,e),d.set(u.y,-u.x),h.addVectors(u,d).add(e),p.subVectors(d,u).add(e),a?(h.toArray(c,3),p.toArray(c,0),p.toArray(c,9)):(h.toArray(c,3),h.toArray(c,9),p.toArray(c,0))):(u.subVectors(r,e),d.set(u.y,-u.x),h.addVectors(u,d).add(e),p.subVectors(d,u).add(e),i=c.length,a?(h.toArray(c,i-3),p.toArray(c,i-6)):(h.toArray(c,i-6),p.toArray(c,i-3)),p.toArray(c,i-12))}}}}THREE.SVGLoader=SVGLoader}{class EXRLoader extends THREE.DataTextureLoader{constructor(e){super(e),this.type=THREE.HalfFloatType}parse(e){const v=65536,T=v>>3;const g=14,h=65537,p=1<<g,E=p-1;const l=32768,r=65535,d=59,f=63,w=2+f-d,c=8,o=4,a=4,A=2,u=1,I=0,F=1,C=0,_=1,P=2,D=Math.pow(2.7182818,2.2);const m={l:0,c:0,lc:0};function getBits(e,t,r,a,s){for(;r<e;)t=t<<8|parseUint8Array(a,s),r+=8;r-=e,m.l=t>>r&(1<<e)-1,m.c=t,m.lc=r}const y=new Array(59);function hufUnpackEncTable(t,r,a,s,n,i){var o=r;let l=0,c=0;for(;s<=n;s++){if(o.value-r.value>a)return;getBits(6,l,c,t,o);var u=m.l;if(l=m.c,c=m.lc,(i[s]=u)==f){if(o.value-r.value>a)throw new Error("Something wrong with hufUnpackEncTable");getBits(8,l,c,t,o);let e=m.l+w;if(l=m.c,c=m.lc,s+e>n+1)throw new Error("Something wrong with hufUnpackEncTable");for(;e--;)i[s++]=0;s--}else if(u>=d){let e=u-d+2;if(s+e>n+1)throw new Error("Something wrong with hufUnpackEncTable");for(;e--;)i[s++]=0;s--}}!function hufCanonicalCodeTable(t){for(let e=0;e<=58;++e)y[e]=0;for(let e=0;e<h;++e)y[t[e]]+=1;let r=0;for(let e=58;0<e;--e){var a=r+y[e]>>1;y[e]=r,r=a}for(let e=0;e<h;++e){var s=t[e];0<s&&(t[e]=s|y[s]++<<6)}}(i)}const R={c:0,lc:0};function getChar(e,t,r,a){e=e<<8|parseUint8Array(r,a),t+=8,R.c=e,R.lc=t}const x={c:0,lc:0};function getCode(e,t,r,a,s,n,i,o,l){if(e==t){a<8&&(getChar(r,a,s,n),r=R.c,a=R.lc);let e=r>>(a-=8);if(e=new Uint8Array([e])[0],o.value+e>l)return;for(var c=i[o.value-1];0<e--;)i[o.value++]=c}else{if(!(o.value<l))return;i[o.value++]=e}x.c=r,x.lc=a}function Int16(e){e&=65535;return 32767<e?e-65536:e}const M={a:0,b:0};function wdec14(e,t){var e=Int16(e),t=Int16(t),e=e+(1&t)+(t>>1),r=e,e=e-t;M.a=r,M.b=e}function wdec16(e,t){t&=65535,e=(65535&e)-(t>>1)&r,t=t+e-l&r;M.a=t,M.b=e}function hufUncompress(e,t,r,a,s,n){var i=r.value,o=parseUint32(t,r),l=parseUint32(t,r),t=(r.value+=4,parseUint32(t,r));if(r.value+=4,o<0||o>=h||l<0||l>=h)throw new Error("Something wrong with HUF_ENCSIZE");var c=new Array(h),u=new Array(p),d=(!function hufClearDecTable(t){for(let e=0;e<p;e++)t[e]={},t[e].len=0,t[e].lit=0,t[e].p=null}(u),a-(r.value-i));if(hufUnpackEncTable(e,r,d,o,l,c),t>8*(a-(r.value-i)))throw new Error("Something wrong with hufUncompress");!function hufBuildDecTable(e,r,t,a){for(;r<=t;r++){var s=e[r]>>6,n=63&e[r];if(s>>n)throw new Error("Invalid table entry");if(n>g){const o=a[s>>n-g];if(o.len)throw new Error("Invalid table entry");if(o.lit++,o.p){var i=o.p;o.p=new Array(o.lit);for(let e=0;e<o.lit-1;++e)o.p[e]=i[e]}else o.p=new Array(1);o.p[o.lit-1]=r}else if(n){let t=0;for(let e=1<<g-n;0<e;e--){const l=a[(s<<g-n)+t];if(l.len||l.p)throw new Error("Invalid table entry");l.len=n,l.lit=r,t++}}}}(c,o,l,u),function hufDecode(t,e,r,a,s,n,i,o,l){let c=0,u=0;for(var d=i,h=Math.trunc(a.value+(s+7)/8);a.value<h;)for(getChar(c,u,r,a),c=R.c,u=R.lc;u>=g;){var p=e[c>>u-g&E];if(p.len)u-=p.len,getCode(p.lit,n,c,u,r,a,o,l,d),c=x.c,u=x.lc;else{if(!p.p)throw new Error("hufDecode issues");let e;for(e=0;e<p.lit;e++){for(var f=63&t[p.p[e]];u<f&&a.value<h;)getChar(c,u,r,a),c=R.c,u=R.lc;if(u>=f&&t[p.p[e]]>>6==(c>>u-f&(1<<f)-1)){u-=f,getCode(p.p[e],n,c,u,r,a,o,l,d),c=x.c,u=x.lc;break}}if(e==p.lit)throw new Error("hufDecode issues")}}for(i=8-s&7,c>>=i,u-=i;0<u;){var m=e[c<<g-u&E];if(!m.len)throw new Error("hufDecode issues");u-=m.len,getCode(m.lit,n,c,u,r,a,o,l,d),c=x.c,u=x.lc}}(c,u,e,r,t,l,n,s,{value:0})}function predictor(t){for(let e=1;e<t.length;e++){var r=t[e-1]+t[e]-128;t[e]=r}}function interleaveScalar(e,t){let r=0,a=Math.floor((e.length+1)/2),s=0;for(var n=e.length-1;!(s>n)&&(t[s++]=e[r++],!(s>n));)t[s++]=e[a++]}function decodeRunLength(e){let t=e.byteLength;const r=new Array;let a=0;const s=new DataView(e);for(;0<t;){var n=s.getInt8(a++);if(n<0){var i=-n;t-=1+i;for(let e=0;e<i;e++)r.push(s.getUint8(a++))}else{var o=n,l=(t-=2,s.getUint8(a++));for(let e=0;e<o+1;e++)r.push(l)}}return r}function lossyDctDecode(o,t,e,r,l,a){let c=new DataView(a.buffer);var s=e[o.idx[0]].width,n=e[o.idx[0]].height,u=Math.floor(s/8),d=Math.ceil(s/8),h=Math.ceil(n/8),p=s-8*(d-1),f=n-8*(h-1),m={value:0};const g=new Array(3),E=new Array(3),v=new Array(3),T=new Array(3),y=new Array(3);for(let e=0;e<3;++e)y[e]=t[o.idx[e]],g[e]=e<1?0:g[e-1]+d*h,E[e]=new Float32Array(64),v[e]=new Uint16Array(64),T[e]=new Uint16Array(64*d);for(let i=0;i<h;++i){let a=8,s=(i==h-1&&(a=f),8);for(let t=0;t<d;++t){t==d-1&&(s=p);for(let e=0;e<3;++e)v[e].fill(0),v[e][0]=l[g[e]++],function unRleAC(e,t,r){let a,s=1;for(;s<64;)65280==(a=t[e.value])?s=64:a>>8==255?s+=255&a:(r[s]=a,s++),e.value++}(m,r,v[e]),function unZigZag(e,t){t[0]=decodeFloat16(e[0]),t[1]=decodeFloat16(e[1]),t[2]=decodeFloat16(e[5]),t[3]=decodeFloat16(e[6]),t[4]=decodeFloat16(e[14]),t[5]=decodeFloat16(e[15]),t[6]=decodeFloat16(e[27]),t[7]=decodeFloat16(e[28]),t[8]=decodeFloat16(e[2]),t[9]=decodeFloat16(e[4]),t[10]=decodeFloat16(e[7]),t[11]=decodeFloat16(e[13]),t[12]=decodeFloat16(e[16]),t[13]=decodeFloat16(e[26]),t[14]=decodeFloat16(e[29]),t[15]=decodeFloat16(e[42]),t[16]=decodeFloat16(e[3]),t[17]=decodeFloat16(e[8]),t[18]=decodeFloat16(e[12]),t[19]=decodeFloat16(e[17]),t[20]=decodeFloat16(e[25]),t[21]=decodeFloat16(e[30]),t[22]=decodeFloat16(e[41]),t[23]=decodeFloat16(e[43]),t[24]=decodeFloat16(e[9]),t[25]=decodeFloat16(e[11]),t[26]=decodeFloat16(e[18]),t[27]=decodeFloat16(e[24]),t[28]=decodeFloat16(e[31]),t[29]=decodeFloat16(e[40]),t[30]=decodeFloat16(e[44]),t[31]=decodeFloat16(e[53]),t[32]=decodeFloat16(e[10]),t[33]=decodeFloat16(e[19]),t[34]=decodeFloat16(e[23]),t[35]=decodeFloat16(e[32]),t[36]=decodeFloat16(e[39]),t[37]=decodeFloat16(e[45]),t[38]=decodeFloat16(e[52]),t[39]=decodeFloat16(e[54]),t[40]=decodeFloat16(e[20]),t[41]=decodeFloat16(e[22]),t[42]=decodeFloat16(e[33]),t[43]=decodeFloat16(e[38]),t[44]=decodeFloat16(e[46]),t[45]=decodeFloat16(e[51]),t[46]=decodeFloat16(e[55]),t[47]=decodeFloat16(e[60]),t[48]=decodeFloat16(e[21]),t[49]=decodeFloat16(e[34]),t[50]=decodeFloat16(e[37]),t[51]=decodeFloat16(e[47]),t[52]=decodeFloat16(e[50]),t[53]=decodeFloat16(e[56]),t[54]=decodeFloat16(e[59]),t[55]=decodeFloat16(e[61]),t[56]=decodeFloat16(e[35]),t[57]=decodeFloat16(e[36]),t[58]=decodeFloat16(e[48]),t[59]=decodeFloat16(e[49]),t[60]=decodeFloat16(e[57]),t[61]=decodeFloat16(e[58]),t[62]=decodeFloat16(e[62]),t[63]=decodeFloat16(e[63])}(v[e],E[e]),!function dctInverse(t){const r=.5*Math.cos(.7853975),a=.5*Math.cos(.196349375),s=.5*Math.cos(.39269875),n=.5*Math.cos(3*3.14159/16),i=.5*Math.cos(.981746875),o=.5*Math.cos(3*3.14159/8),l=.5*Math.cos(1.374445625),c=new Array(4),u=new Array(4),d=new Array(4),h=new Array(4);for(let e=0;e<8;++e){var p=8*e;c[0]=s*t[2+p],c[1]=o*t[2+p],c[2]=s*t[6+p],c[3]=o*t[6+p],u[0]=a*t[1+p]+n*t[3+p]+i*t[5+p]+l*t[7+p],u[1]=n*t[1+p]-l*t[3+p]-a*t[5+p]-i*t[7+p],u[2]=i*t[1+p]-a*t[3+p]+l*t[5+p]+n*t[7+p],u[3]=l*t[1+p]-i*t[3+p]+n*t[5+p]-a*t[7+p],d[0]=r*(t[0+p]+t[4+p]),d[3]=r*(t[0+p]-t[4+p]),d[1]=c[0]+c[3],d[2]=c[1]-c[2],h[0]=d[0]+d[1],h[1]=d[3]+d[2],h[2]=d[3]-d[2],h[3]=d[0]-d[1],t[0+p]=h[0]+u[0],t[1+p]=h[1]+u[1],t[2+p]=h[2]+u[2],t[3+p]=h[3]+u[3],t[4+p]=h[3]-u[3],t[5+p]=h[2]-u[2],t[6+p]=h[1]-u[1],t[7+p]=h[0]-u[0]}for(let e=0;e<8;++e)c[0]=s*t[16+e],c[1]=o*t[16+e],c[2]=s*t[48+e],c[3]=o*t[48+e],u[0]=a*t[8+e]+n*t[24+e]+i*t[40+e]+l*t[56+e],u[1]=n*t[8+e]-l*t[24+e]-a*t[40+e]-i*t[56+e],u[2]=i*t[8+e]-a*t[24+e]+l*t[40+e]+n*t[56+e],u[3]=l*t[8+e]-i*t[24+e]+n*t[40+e]-a*t[56+e],d[0]=r*(t[e]+t[32+e]),d[3]=r*(t[e]-t[32+e]),d[1]=c[0]+c[3],d[2]=c[1]-c[2],h[0]=d[0]+d[1],h[1]=d[3]+d[2],h[2]=d[3]-d[2],h[3]=d[0]-d[1],t[0+e]=h[0]+u[0],t[8+e]=h[1]+u[1],t[16+e]=h[2]+u[2],t[24+e]=h[3]+u[3],t[32+e]=h[3]-u[3],t[40+e]=h[2]-u[2],t[48+e]=h[1]-u[1],t[56+e]=h[0]-u[0]}(E[e]);!function csc709Inverse(t){for(let e=0;e<64;++e){var r=t[0][e],a=t[1][e],s=t[2][e];t[0][e]=r+1.5747*s,t[1][e]=r-.1873*a-.4682*s,t[2][e]=r+1.8556*a}}(E);for(let e=0;e<3;++e)!function convertToHalf(t,r,a){for(let e=0;e<64;++e)r[a+e]=THREE.DataUtils.toHalfFloat(function toLinear(e){return e<=1?Math.sign(e)*Math.pow(Math.abs(e),2.2):Math.sign(e)*Math.pow(D,Math.abs(e)-1)}(t[e]))}(E[e],T[e],64*t)}let n=0;for(let r=0;r<3;++r){var R=e[o.idx[r]].type;for(let t=8*i;t<8*i+a;++t){n=y[r][t];for(let e=0;e<u;++e){var x=64*e+8*(7&t);c.setUint16(n+0*A*R,T[r][x],!0),c.setUint16(n+ +A*R,T[r][1+x],!0),c.setUint16(n+2*A*R,T[r][2+x],!0),c.setUint16(n+3*A*R,T[r][3+x],!0),c.setUint16(n+4*A*R,T[r][4+x],!0),c.setUint16(n+5*A*R,T[r][5+x],!0),c.setUint16(n+6*A*R,T[r][6+x],!0),c.setUint16(n+7*A*R,T[r][7+x],!0),n+=8*A*R}}if(u!=d)for(let e=8*i;e<8*i+a;++e){var w=y[r][e]+8*u*A*R,b=64*u+8*(7&e);for(let e=0;e<s;++e)c.setUint16(w+e*A*R,T[r][b+e],!0)}}}const i=new Uint16Array(s);c=new DataView(a.buffer);for(let t=0;t<3;++t){e[o.idx[t]].decoded=!0;var S=e[o.idx[t]].type;if(2==e[t].type)for(let e=0;e<n;++e){var M=y[t][e];for(let e=0;e<s;++e)i[e]=c.getUint16(M+e*A*S,!0);for(let e=0;e<s;++e)c.setFloat32(M+e*A*S,decodeFloat16(i[e]),!0)}}}function uncompressRAW(e){return new DataView(e.array.buffer,e.offset.value,e.size)}function uncompressRLE(e){var e=e.viewer.buffer.slice(e.offset.value,e.offset.value+e.size),e=new Uint8Array(decodeRunLength(e)),t=new Uint8Array(e.length);return predictor(e),interleaveScalar(e,t),new DataView(t.buffer)}function uncompressZIP(e){var e=e.array.slice(e.offset.value,e.offset.value+e.size),e=("undefined"==typeof fflate&&console.error("THREE.EXRLoader: External library fflate.min.js required."),fflate.unzlibSync(e)),t=new Uint8Array(e.length);return predictor(e),interleaveScalar(e,t),new DataView(t.buffer)}function uncompressPIZ(r){var t=r.viewer,a={value:r.offset.value},s=new Uint16Array(r.width*r.scanlineBlockSize*(r.channels*r.type));const n=new Uint8Array(T);let i=0;const o=new Array(r.channels);for(let e=0;e<r.channels;e++)o[e]={},o[e].start=i,o[e].end=o[e].start,o[e].nx=r.width,o[e].ny=r.lines,o[e].size=r.type,i+=o[e].nx*o[e].ny*o[e].size;var l=parseUint16(t,a),c=parseUint16(t,a);if(c>=T)throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");if(l<=c)for(let e=0;e<c-l+1;e++)n[e+l]=parseUint8(t,a);var e=new Uint16Array(v),u=function reverseLutFromBitmap(t,r){let a=0;for(let e=0;e<v;++e)(0==e||t[e>>3]&1<<(7&e))&&(r[a++]=e);for(var e=a-1;a<v;)r[a++]=0;return e}(n,e),d=parseUint32(t,a);hufUncompress(r.array,t,a,d,s,i);for(let t=0;t<r.channels;++t){var h=o[t];for(let e=0;e<o[t].size;++e)!function wav2Decode(n,i,o,l,e,c,t){var u=t<16384,r=e<o?e:o;let d=1,h,p;for(;d<=r;)d<<=1;for(d>>=1,h=d,d>>=1;1<=d;){var f=(p=0)+c*(e-h),m=c*d,g=c*h,E=l*d,v=l*h;let t,r,a,s;for(;p<=f;p+=g){let e=p;for(var T,y=p+l*(o-h);e<=y;e+=v){var R=e+E,x=e+m,w=x+E;u?(wdec14(n[e+i],n[x+i]),t=M.a,a=M.b,wdec14(n[R+i],n[w+i]),r=M.a,s=M.b,wdec14(t,r),n[e+i]=M.a,n[R+i]=M.b,wdec14(a,s)):(wdec16(n[e+i],n[x+i]),t=M.a,a=M.b,wdec16(n[R+i],n[w+i]),r=M.a,s=M.b,wdec16(t,r),n[e+i]=M.a,n[R+i]=M.b,wdec16(a,s)),n[x+i]=M.a,n[w+i]=M.b}o&d&&(T=e+m,(u?wdec14:wdec16)(n[e+i],n[T+i]),t=M.a,n[T+i]=M.b,n[e+i]=t)}if(e&d){let e=p;for(var b=p+l*(o-h);e<=b;e+=v){var S=e+E;(u?wdec14:wdec16)(n[e+i],n[S+i]),t=M.a,n[S+i]=M.b,n[e+i]=t}}h=d,d>>=1}p}(s,h.start+e,h.nx,h.size,h.ny,h.nx*h.size,u)}!function applyLut(t,r,a){for(let e=0;e<a;++e)r[e]=t[r[e]]}(e,s,i);let p=0;const f=new Uint8Array(s.buffer.byteLength);for(let e=0;e<r.lines;e++)for(let e=0;e<r.channels;e++){const E=o[e];var m=E.nx*E.size,g=new Uint8Array(s.buffer,E.end*A,m*A);f.set(g,p),p+=m*A,E.end+=m}return new DataView(f.buffer)}function uncompressPXR(r){var e=r.array.slice(r.offset.value,r.offset.value+r.size),a=("undefined"==typeof fflate&&console.error("THREE.EXRLoader: External library fflate.min.js required."),fflate.unzlibSync(e)),e=r.lines*r.channels*r.width;const s=new(1==r.type?Uint16Array:Uint32Array)(e);let n=0,i=0;const o=new Array(4);for(let e=0;e<r.lines;e++)for(let e=0;e<r.channels;e++){let t=0;switch(r.type){case 1:o[0]=n,o[1]=o[0]+r.width,n=o[1]+r.width;for(let e=0;e<r.width;++e){var l=a[o[0]++]<<8|a[o[1]++];t+=l,s[i]=t,i++}break;case 2:o[0]=n,o[1]=o[0]+r.width,o[2]=o[1]+r.width,n=o[2]+r.width;for(let e=0;e<r.width;++e){var c=a[o[0]++]<<24|a[o[1]++]<<16|a[o[2]++]<<8;t+=c,s[i]=t,i++}}}return new DataView(s.buffer)}function uncompressDWA(n){var e=n.viewer;const t={value:n.offset.value},i=new Uint8Array(n.width*n.lines*(n.channels*n.type*A));var r={version:L(e,t),unknownUncompressedSize:L(e,t),unknownCompressedSize:L(e,t),acCompressedSize:L(e,t),dcCompressedSize:L(e,t),rleCompressedSize:L(e,t),rleUncompressedSize:L(e,t),rleRawSize:L(e,t),totalAcUncompressedCount:L(e,t),totalDcUncompressedCount:L(e,t),acCompression:L(e,t)};if(r.version<2)throw new Error("EXRLoader.parse: "+H.compression+" version "+r.version+" is unsupported");const a=new Array;let s=parseUint16(e,t)-A;for(;0<s;){var o=parseNullTerminatedString(e.buffer,t),l=parseUint8(e,t),c=l>>2&3,l=new Int8Array([(l>>4)-1])[0],u=parseUint8(e,t);a.push({name:o,index:l,type:u,compression:c}),s-=o.length+3}var d,h=H.channels;const p=new Array(n.channels);for(let e=0;e<n.channels;++e){const b=p[e]={};var f=h[e];b.name=f.name,b.compression=C,b.decoded=!1,b.type=f.pixelType,b.pLinear=f.pLinear,b.width=n.width,b.height=n.lines}const m={idx:new Array(3)};for(let t=0;t<n.channels;++t){const S=p[t];for(let e=0;e<a.length;++e){var g=a[e];S.name==g.name&&(S.compression=g.compression,0<=g.index&&(m.idx[g.index]=t),S.offset=t)}}let E,v,T;if(0<r.acCompressedSize)switch(r.acCompression){case I:E=new Uint16Array(r.totalAcUncompressedCount),hufUncompress(n.array,e,t,r.acCompressedSize,E,r.totalAcUncompressedCount);break;case F:var y=n.array.slice(t.value,t.value+r.totalAcUncompressedCount),y=fflate.unzlibSync(y);E=new Uint16Array(y.buffer),t.value+=r.totalAcUncompressedCount}0<r.dcCompressedSize&&(d={array:n.array,offset:t,size:r.dcCompressedSize},v=new Uint16Array(uncompressZIP(d).buffer),t.value+=r.dcCompressedSize),0<r.rleRawSize&&(d=n.array.slice(t.value,t.value+r.rleCompressedSize),d=fflate.unzlibSync(d),T=decodeRunLength(d.buffer),t.value+=r.rleCompressedSize);let R=0;const x=new Array(p.length);for(let e=0;e<x.length;++e)x[e]=new Array;for(let e=0;e<n.lines;++e)for(let e=0;e<p.length;++e)x[e].push(R),R+=p[e].width*n.type*A;lossyDctDecode(m,x,p,E,v,i);for(let s=0;s<p.length;++s){var w=p[s];if(!w.decoded){if(w.compression!==P)throw _,new Error("EXRLoader.parse: unsupported channel compression");{let r=0,a=0;for(let e=0;e<n.lines;++e){let t=x[s][r];for(let e=0;e<w.width;++e){for(let e=0;e<A*w.type;++e)i[t++]=T[a+e*w.width*w.height];a++}r++}}}}return new DataView(i.buffer)}function parseNullTerminatedString(e,t){const r=new Uint8Array(e);let a=0;for(;0!=r[t.value+a];)a+=1;e=(new TextDecoder).decode(r.slice(t.value,t.value+a));return t.value=t.value+a+1,e}function parseInt32(e,t){e=e.getInt32(t.value,!0);return t.value=t.value+a,e}function parseUint32(e,t){e=e.getUint32(t.value,!0);return t.value=t.value+a,e}function parseUint8Array(e,t){e=e[t.value];return t.value=t.value+u,e}function parseUint8(e,t){e=e.getUint8(t.value);return t.value=t.value+u,e}const L=function(e,t){let r;return r="getBigInt64"in DataView.prototype?Number(e.getBigInt64(t.value,!0)):e.getUint32(t.value+4,!0)+Number(e.getUint32(t.value,!0)<<32),t.value+=c,r};function parseFloat32(e,t){e=e.getFloat32(t.value,!0);return t.value+=o,e}function decodeFloat32(e,t){return THREE.DataUtils.toHalfFloat(parseFloat32(e,t))}function decodeFloat16(e){var t=(31744&e)>>10,r=1023&e;return(e>>15?-1:1)*(t?31==t?r?NaN:1/0:Math.pow(2,t-15)*(1+r/1024):r/1024*6103515625e-14)}function parseUint16(e,t){e=e.getUint16(t.value,!0);return t.value+=A,e}function parseFloat16(e,t){return decodeFloat16(parseUint16(e,t))}function parseValue(e,t,r,a,s){return"string"===a||"stringvector"===a||"iccProfile"===a?function parseFixedLengthString(e,t,r){return e=(new TextDecoder).decode(new Uint8Array(e).slice(t.value,t.value+r)),t.value=t.value+r,e}(t,r,s):"chlist"===a?function parseChlist(e,t,r,a){var s=r.value;const n=[];for(;r.value<s+a-1;){var i=parseNullTerminatedString(t,r),o=parseInt32(e,r),l=parseUint8(e,r),c=(r.value+=3,parseInt32(e,r)),u=parseInt32(e,r);n.push({name:i,pixelType:o,pLinear:l,xSampling:c,ySampling:u})}return r.value+=1,n}(e,t,r,s):"chromaticities"===a?function parseChromaticities(e,t){return{redX:parseFloat32(e,t),redY:parseFloat32(e,t),greenX:parseFloat32(e,t),greenY:parseFloat32(e,t),blueX:parseFloat32(e,t),blueY:parseFloat32(e,t),whiteX:parseFloat32(e,t),whiteY:parseFloat32(e,t)}}(e,r):"compression"===a?function parseCompression(e,t){return["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"][parseUint8(e,t)]}(e,r):"box2i"===a?function parseBox2i(e,t){return{xMin:parseUint32(e,t),yMin:parseUint32(e,t),xMax:parseUint32(e,t),yMax:parseUint32(e,t)}}(e,r):"lineOrder"===a?function parseLineOrder(e,t){return["INCREASING_Y"][parseUint8(e,t)]}(e,r):"float"===a?parseFloat32(e,r):"v2f"===a?function parseV2f(e,t){return[parseFloat32(e,t),parseFloat32(e,t)]}(e,r):"v3f"===a?function parseV3f(e,t){return[parseFloat32(e,t),parseFloat32(e,t),parseFloat32(e,t)]}(e,r):"int"===a?parseInt32(e,r):"rational"===a?function parseRational(e,t){return[parseInt32(e,t),parseUint32(e,t)]}(e,r):"timecode"===a?function parseTimecode(e,t){return[parseUint32(e,t),parseUint32(e,t)]}(e,r):"preview"===a?(r.value+=s,"skipped"):void(r.value+=s)}var t=new DataView(e),b=new Uint8Array(e);const s={value:0},H=function parseHeader(e,t,r){const a={};if(20000630!=e.getUint32(0,!0))throw new Error("THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.");a.version=e.getUint8(4);var s=e.getUint8(5);a.spec={singleTile:!!(2&s),longName:!!(4&s),deepFormat:!!(8&s),multiPart:!!(16&s)},r.value=8;let n=!0;for(;n;){var i,o,l=parseNullTerminatedString(t,r);0==l?n=!1:void 0===(o=parseValue(e,t,r,i=parseNullTerminatedString(t,r),parseUint32(e,r)))?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${i}'.`):a[l]=o}if(0!=s)throw console.error("EXRHeader:",a),new Error("THREE.EXRLoader: provided file is currently unsupported.");return a}(t,e,s),n=function setupDecoder(e,t,r,a,s){const n={size:0,viewer:t,array:r,offset:a,width:e.dataWindow.xMax-e.dataWindow.xMin+1,height:e.dataWindow.yMax-e.dataWindow.yMin+1,channels:e.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:e.channels[0].pixelType,uncompress:null,getter:null,format:null,encoding:null};switch(e.compression){case"NO_COMPRESSION":n.lines=1,n.uncompress=uncompressRAW;break;case"RLE_COMPRESSION":n.lines=1,n.uncompress=uncompressRLE;break;case"ZIPS_COMPRESSION":n.lines=1,n.uncompress=uncompressZIP;break;case"ZIP_COMPRESSION":n.lines=16,n.uncompress=uncompressZIP;break;case"PIZ_COMPRESSION":n.lines=32,n.uncompress=uncompressPIZ;break;case"PXR24_COMPRESSION":n.lines=16,n.uncompress=uncompressPXR;break;case"DWAA_COMPRESSION":n.lines=32,n.uncompress=uncompressDWA;break;case"DWAB_COMPRESSION":n.lines=256,n.uncompress=uncompressDWA;break;default:throw new Error("EXRLoader.parse: "+e.compression+" is unsupported")}if(n.scanlineBlockSize=n.lines,1==n.type)switch(s){case THREE.FloatType:n.getter=parseFloat16,n.inputSize=A;break;case THREE.HalfFloatType:n.getter=parseUint16,n.inputSize=A}else{if(2!=n.type)throw new Error("EXRLoader.parse: unsupported pixelType "+n.type+" for "+e.compression+".");switch(s){case THREE.FloatType:n.getter=parseFloat32,n.inputSize=o;break;case THREE.HalfFloatType:n.getter=decodeFloat32,n.inputSize=o}}n.blockCount=(e.dataWindow.yMax+1)/n.scanlineBlockSize;for(let e=0;e<n.blockCount;e++)L(t,a);n.outputChannels=3==n.channels?4:n.channels;var i=n.width*n.height*n.outputChannels;switch(s){case THREE.FloatType:n.byteArray=new Float32Array(i),n.channels<n.outputChannels&&n.byteArray.fill(1,0,i);break;case THREE.HalfFloatType:n.byteArray=new Uint16Array(i),n.channels<n.outputChannels&&n.byteArray.fill(15360,0,i);break;default:console.error("THREE.EXRLoader: unsupported type: ",s)}return n.bytesPerLine=n.width*n.inputSize*n.channels,4==n.outputChannels?n.format=THREE.RGBAFormat:n.format=THREE.RedFormat,n.encoding=THREE.LinearEncoding,n}(H,t,b,s,this.type),S={value:0};var U={R:0,G:1,B:2,A:3,Y:0};for(let e=0;e<n.height/n.scanlineBlockSize;e++){var i=parseUint32(t,s),i=(n.size=parseUint32(t,s),n.lines=i+n.scanlineBlockSize>n.height?n.height-i:n.scanlineBlockSize,n.size<n.lines*n.bytesPerLine),N=i?n.uncompress(n):uncompressRAW(n);s.value+=n.size;for(let r=0;r<n.scanlineBlockSize;r++){var O=r+e*n.scanlineBlockSize;if(O>=n.height)break;for(let t=0;t<n.channels;t++){var k=U[H.channels[t].name];for(let e=0;e<n.width;e++){S.value=(r*(n.channels*n.width)+t*n.width+e)*n.inputSize;var B=(n.height-1-O)*(n.width*n.outputChannels)+e*n.outputChannels+k;n.byteArray[B]=n.getter(N,S)}}}}return{header:H,width:n.width,height:n.height,data:n.byteArray,format:n.format,encoding:n.encoding,type:this.type}}setDataType(e){return this.type=e,this}load(e,r,t,a){return super.load(e,function onLoadCallback(e,t){e.encoding=t.encoding,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,e.generateMipmaps=!1,e.flipY=!1,r&&r(e,t)},t,a)}}THREE.EXRLoader=EXRLoader}function mergeBufferAttributes(t){let r,a,s,n=0;for(let e=0;e<t.length;++e){var i=t[e];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if((r=void 0===r?i.array.constructor:r)!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes."),null;if((a=void 0===a?i.itemSize:a)!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes."),null;if((s=void 0===s?i.normalized:s)!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes."),null;n+=i.array.length}const o=new r(n);let l=0;for(let e=0;e<t.length;++e)o.set(t[e].array,l),l+=t[e].array.length;return new THREE.BufferAttribute(o,a,s)}THREE.BufferGeometryUtils={},THREE.BufferGeometryUtils.computeMorphedAttributes=function computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry."),null;const h=new THREE.Vector3,p=new THREE.Vector3,f=new THREE.Vector3,m=new THREE.Vector3,g=new THREE.Vector3,E=new THREE.Vector3,v=new THREE.Vector3,T=new THREE.Vector3,y=new THREE.Vector3;function _calculateMorphedAttributeData(e,t,r,a,s,n,i,o,l){h.fromBufferAttribute(r,n),p.fromBufferAttribute(r,i),f.fromBufferAttribute(r,o);var c=e.morphTargetInfluences;if(t.morphTargets&&a&&c){v.set(0,0,0),T.set(0,0,0),y.set(0,0,0);for(let e=0,t=a.length;e<t;e++){var u=c[e],d=a[e];0!==u&&(m.fromBufferAttribute(d,n),g.fromBufferAttribute(d,i),E.fromBufferAttribute(d,o),s?(v.addScaledVector(m,u),T.addScaledVector(g,u),y.addScaledVector(E,u)):(v.addScaledVector(m.sub(h),u),T.addScaledVector(g.sub(p),u),y.addScaledVector(E.sub(f),u)))}h.add(v),p.add(T),f.add(y)}e.isSkinnedMesh&&(e.boneTransform(n,h),e.boneTransform(i,p),e.boneTransform(o,f)),l[3*n+0]=h.x,l[3*n+1]=h.y,l[3*n+2]=h.z,l[3*i+0]=p.x,l[3*i+1]=p.y,l[3*i+2]=p.z,l[3*o+0]=f.x,l[3*o+1]=f.y,l[3*o+2]=f.z}var t=e.geometry,r=e.material;let a,s,n;const i=t.index;var o=t.attributes.position,l=t.morphAttributes.position,c=t.morphTargetsRelative,u=t.attributes.normal,d=t.morphAttributes.position,R=t.groups,x=t.drawRange;let w,b,S,M,A,L,H,I;var F=new Float32Array(o.count*o.itemSize),C=new Float32Array(u.count*u.itemSize);if(null!==i)if(Array.isArray(r))for(w=0,S=R.length;w<S;w++)for(A=R[w],L=r[A.materialIndex],H=Math.max(A.start,x.start),I=Math.min(A.start+A.count,x.start+x.count),b=H,M=I;b<M;b+=3)a=i.getX(b),s=i.getX(b+1),n=i.getX(b+2),_calculateMorphedAttributeData(e,L,o,l,c,a,s,n,F),_calculateMorphedAttributeData(e,L,u,d,c,a,s,n,C);else for(H=Math.max(0,x.start),I=Math.min(i.count,x.start+x.count),w=H,S=I;w<S;w+=3)a=i.getX(w),s=i.getX(w+1),n=i.getX(w+2),_calculateMorphedAttributeData(e,r,o,l,c,a,s,n,F),_calculateMorphedAttributeData(e,r,u,d,c,a,s,n,C);else if(Array.isArray(r))for(w=0,S=R.length;w<S;w++)for(A=R[w],L=r[A.materialIndex],H=Math.max(A.start,x.start),I=Math.min(A.start+A.count,x.start+x.count),b=H,M=I;b<M;b+=3)a=b,s=b+1,n=b+2,_calculateMorphedAttributeData(e,L,o,l,c,a,s,n,F),_calculateMorphedAttributeData(e,L,u,d,c,a,s,n,C);else for(H=Math.max(0,x.start),I=Math.min(o.count,x.start+x.count),w=H,S=I;w<S;w+=3)a=w,s=w+1,n=w+2,_calculateMorphedAttributeData(e,r,o,l,c,a,s,n,F),_calculateMorphedAttributeData(e,r,u,d,c,a,s,n,C);return{positionAttribute:o,normalAttribute:u,morphedPositionAttribute:new THREE.Float32BufferAttribute(F,3),morphedNormalAttribute:new THREE.Float32BufferAttribute(C,3)}},THREE.BufferGeometryUtils.computeTangents=function computeTangents(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use THREE.BufferGeometry.computeTangents() instead.")},THREE.BufferGeometryUtils.estimateBytesUsed=function estimateBytesUsed(e){let t=0;for(const s in e.attributes){var r=e.getAttribute(s);t+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}var a=e.getIndex();return t+=a?a.count*a.itemSize*a.array.BYTES_PER_ELEMENT:0},THREE.BufferGeometryUtils.interleaveAttributes=function interleaveAttributes(r){let a,s=0,n=0;for(let e=0,t=r.length;e<t;++e){var i=r[e];if((a=void 0===a?i.array.constructor:a)!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;s+=i.array.length,n+=i.itemSize}var o=new THREE.InterleavedBuffer(new a(s),n);let l=0;const c=[];var u=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"];for(let e=0,t=r.length;e<t;e++){const f=r[e];var h=f.itemSize,p=f.count;const m=new THREE.InterleavedBufferAttribute(o,h,l,f.normalized);c.push(m),l+=h;for(let t=0;t<p;t++)for(let e=0;e<h;e++)m[d[e]](t,f[u[e]](t))}return c},THREE.BufferGeometryUtils.mergeBufferAttributes=mergeBufferAttributes,THREE.BufferGeometryUtils.mergeBufferGeometries=function mergeBufferGeometries(r,a=!1){var s=null!==r[0].index;const n=new Set(Object.keys(r[0].attributes)),i=new Set(Object.keys(r[0].morphAttributes)),o={},l={};var c=r[0].morphTargetsRelative;const u=new THREE.BufferGeometry;let d=0;for(let t=0;t<r.length;++t){var h=r[t];let e=0;if(s!=(null!==h.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const m in h.attributes){if(!n.has(m))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+m+'" attribute exists among all geometries, or in none of them.'),null;void 0===o[m]&&(o[m]=[]),o[m].push(h.attributes[m]),e++}if(e!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". Make sure all geometries have the same number of attributes."),null;if(c!==h.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const g in h.morphAttributes){if(!i.has(g))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[g]&&(l[g]=[]),l[g].push(h.morphAttributes[g])}if(u.userData.mergedUserData=u.userData.mergedUserData||[],u.userData.mergedUserData.push(h.userData),a){let e;if(s)e=h.index.count;else{if(void 0===h.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+t+". The geometry must have either an index or a position attribute"),null;e=h.attributes.position.count}u.addGroup(d,e,t),d+=e}}if(s){let t=0;const E=[];for(let e=0;e<r.length;++e){const v=r[e].index;for(let e=0;e<v.count;++e)E.push(v.getX(e)+t);t+=r[e].attributes.position.count}u.setIndex(E)}for(const t in o){var e=mergeBufferAttributes(o[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;u.setAttribute(t,e)}for(const T in l){var p=l[T][0].length;if(0===p)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[T]=[];for(let t=0;t<p;++t){const y=[];for(let e=0;e<l[T].length;++e)y.push(l[T][e][t]);var f=mergeBufferAttributes(y);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+T+" morphAttribute."),null;u.morphAttributes[T].push(f)}}return u},THREE.BufferGeometryUtils.mergeVertices=function mergeVertices(a,e=1e-4){e=Math.max(e,Number.EPSILON);const t={},s=a.getIndex();var r=a.getAttribute("position"),n=(s||r).count;let i=0;var o=Object.keys(a.attributes);const l={},c={},u=[];var d=["getX","getY","getZ","getW"];for(let e=0,t=o.length;e<t;e++){var h=o[e],p=(l[h]=[],a.morphAttributes[h]);p&&(c[h]=new Array(p.length).fill().map(()=>[]))}var r=Math.log10(1/e),f=Math.pow(10,r);for(let e=0;e<n;e++){var m=s?s.getX(e):e;let r="";for(let e=0,t=o.length;e<t;e++){var g=o[e];const S=a.getAttribute(g);var E=S.itemSize;for(let e=0;e<E;e++)r+=~~(S[d[e]](m)*f)+","}if(r in t)u.push(t[r]);else{for(let e=0,t=o.length;e<t;e++){var v=o[e];const M=a.getAttribute(v),A=a.morphAttributes[v];var T=M.itemSize;const L=l[v],H=c[v];for(let e=0;e<T;e++){var y=d[e];if(L.push(M[y](m)),A)for(let e=0,t=A.length;e<t;e++)H[e].push(A[e][y](m))}}t[r]=i,u.push(i),i++}}const R=a.clone();for(let e=0,t=o.length;e<t;e++){var x=o[e];const I=a.getAttribute(x);var w=new I.array.constructor(l[x]),w=new THREE.BufferAttribute(w,I.itemSize,I.normalized);if(R.setAttribute(x,w),x in c)for(let e=0;e<c[x].length;e++){const F=a.morphAttributes[x][e];var b=new F.array.constructor(c[x][e]),b=new THREE.BufferAttribute(b,F.itemSize,F.normalized);R.morphAttributes[x][e]=b}}return R.setIndex(u),R},THREE.BufferGeometryUtils.toTrianglesDrawMode=function toTrianglesDrawMode(e,r){if(r===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r!==THREE.TriangleFanDrawMode&&r!==THREE.TriangleStripDrawMode)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e;{let t=e.getIndex();if(null===t){const o=[];var a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<a.count;e++)o.push(e);e.setIndex(o),t=e.getIndex()}var s=t.count-2;const n=[];if(r===THREE.TriangleFanDrawMode)for(let e=1;e<=s;e++)n.push(t.getX(0)),n.push(t.getX(e)),n.push(t.getX(e+1));else for(let e=0;e<s;e++)e%2==0?(n.push(t.getX(e)),n.push(t.getX(e+1)),n.push(t.getX(e+2))):(n.push(t.getX(e+2)),n.push(t.getX(e+1)),n.push(t.getX(e)));n.length/3!=s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=e.clone();return i.setIndex(n),i.clearGroups(),i}};{const d=new THREE.Matrix4,h=new THREE.CSMFrustum,p=new THREE.Vector3,f=new THREE.Box3,m=[],g=[];return void(THREE.CSM=class CSM{constructor(e){this.camera=(e=e||{}).camera,this.parent=e.parent,this.cascades=e.cascades||3,this.maxFar=e.maxFar||1e5,this.mode=e.mode||"practical",this.shadowMapSize=e.shadowMapSize||2048,this.shadowBias=e.shadowBias||1e-6,this.lightDirection=e.lightDirection||new THREE.Vector3(1,-1,1).normalize(),this.lightIntensity=e.lightIntensity||1,this.lightNear=e.lightNear||1,this.lightFar=e.lightFar||2e3,this.lightMargin=e.lightMargin||200,this.customSplitsCallback=e.customSplitsCallback,this.fade=!1,this.mainFrustum=new THREE.CSMFrustum,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}createLights(){for(let e=0;e<this.cascades;e++){const t=new THREE.DirectionalLight(16777215,this.lightIntensity);t.castShadow=!0,t.shadow.mapSize.width=this.shadowMapSize,t.shadow.mapSize.height=this.shadowMapSize,t.shadow.camera.near=this.lightNear,t.shadow.camera.far=this.lightFar,t.shadow.bias=this.shadowBias,this.parent.add(t),this.parent.add(t.target),this.lights.push(t)}}initCascades(){const e=this.camera;e.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}updateShadowBounds(){var e=this.frustums;for(let r=0;r<e.length;r++){const i=this.lights[r].shadow.camera;var a=this.frustums[r],s=a.vertices.near,n=a.vertices.far;const o=n[0];let e,t=(e=(o.distanceTo(n[2])>o.distanceTo(s[2])?n:s)[2],o.distanceTo(e));this.fade&&(n=this.camera,s=Math.max(n.far,this.maxFar),a=a.vertices.far[0].z/(s-n.near),a=.25*Math.pow(a,2)*(s-n.near),t+=a),i.left=-t/2,i.right=t/2,i.top=t/2,i.bottom=-t/2,i.updateProjectionMatrix()}}getBreaks(){var e=this.camera,t=Math.min(e.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":uniformSplit(this.cascades,e.near,t,this.breaks);break;case"logarithmic":logarithmicSplit(this.cascades,e.near,t,this.breaks);break;case"practical":!function practicalSplit(t,e,r,a,s){m.length=0,g.length=0,logarithmicSplit(t,e,r,g),uniformSplit(t,e,r,m);for(let e=1;e<t;e++)s.push(THREE.MathUtils.lerp(m[e-1],g[e-1],a));s.push(1)}(this.cascades,e.near,t,.5,this.breaks);break;case"custom":void 0===this.customSplitsCallback&&console.error("CSM: Custom split scheme callback not defined."),this.customSplitsCallback(this.cascades,e.near,t,this.breaks)}function uniformSplit(t,r,a,s){for(let e=1;e<t;e++)s.push((r+(a-r)*e/t)/a);s.push(1)}function logarithmicSplit(t,r,a,s){for(let e=1;e<t;e++)s.push(r*(a/r)**(e/t)/a);s.push(1)}}update(){var t=this.camera;const r=this.frustums;for(let e=0;e<r.length;e++){const o=this.lights[e];var a=o.shadow.camera,s=(a.right-a.left)/this.shadowMapSize,a=(a.top-a.bottom)/this.shadowMapSize,n=(o.shadow.camera.updateMatrixWorld(!0),d.multiplyMatrices(o.shadow.camera.matrixWorldInverse,t.matrixWorld),r[e].toSpace(d,h),h.vertices.near),i=h.vertices.far;f.makeEmpty();for(let e=0;e<4;e++)f.expandByPoint(n[e]),f.expandByPoint(i[e]);f.getCenter(p),p.z=f.max.z+this.lightMargin,p.x=Math.floor(p.x/s)*s,p.y=Math.floor(p.y/a)*a,p.applyMatrix4(o.shadow.camera.matrixWorld),o.position.copy(p),o.target.position.copy(p),o.target.position.x+=this.lightDirection.x,o.target.position.y+=this.lightDirection.y,o.target.position.z+=this.lightDirection.z}}injectInclude(){THREE.ShaderChunk.lights_fragment_begin=THREE.CSMShader.lights_fragment_begin,THREE.ShaderChunk.lights_pars_begin=THREE.CSMShader.lights_pars_begin}setupMaterial(r){r.defines=r.defines||{},r.defines.USE_CSM=1,r.defines.CSM_CASCADES=this.cascades,this.fade&&(r.defines.CSM_FADE="");const a=[],s=this,n=this.shaders;r.onBeforeCompile=function(e){var t=Math.min(s.camera.far,s.maxFar);s.getExtendedBreaks(a),e.uniforms.CSM_cascades={value:a},e.uniforms.cameraNear={value:s.camera.near},e.uniforms.shadowFar={value:t},n.set(r,e)},n.set(r,null)}updateUniforms(){const a=Math.min(this.camera.far,this.maxFar),e=this.shaders;e.forEach(function(e,t){if(null!==e){const r=e.uniforms;this.getExtendedBreaks(r.CSM_cascades.value),r.cameraNear.value=this.camera.near,r.shadowFar.value=a}!this.fade&&"CSM_FADE"in t.defines?(delete t.defines.CSM_FADE,t.needsUpdate=!0):!this.fade||"CSM_FADE"in t.defines||(t.defines.CSM_FADE="",t.needsUpdate=!0)},this)}getExtendedBreaks(t){for(;t.length<this.breaks.length;)t.push(new THREE.Vector2);t.length=this.breaks.length;for(let e=0;e<this.cascades;e++){var r=this.breaks[e],a=this.breaks[e-1]||0;t[e].x=a,t[e].y=r}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}remove(){for(let e=0;e<this.lights.length;e++)this.parent.remove(this.lights[e])}dispose(){const e=this.shaders;e.forEach(function(e,t){delete t.onBeforeCompile,delete t.defines.USE_CSM,delete t.defines.CSM_CASCADES,delete t.defines.CSM_FADE,null!==e&&(delete e.uniforms.CSM_cascades,delete e.uniforms.cameraNear,delete e.uniforms.shadowFar),t.needsUpdate=!0}),e.clear()}})}}}]);